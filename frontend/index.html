<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI äº§å“æ–‡æ¡£å®¡æŸ¥</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" />
  <style>
    body { font-family: Arial, sans-serif; background: #f7f7f9; color: #1f2937; margin: 0; padding: 0; }
    header { background: #0f172a; color: #fff; padding: 16px 24px; }
    main { max-width: 1080px; margin: 24px auto; padding: 0 16px 48px; }
    .card { background: #fff; border-radius: 10px; box-shadow: 0 10px 30px rgba(15, 23, 42, 0.08); padding: 20px; margin-bottom: 18px; }
    .flex { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .btn { background: #2563eb; color: #fff; border: none; border-radius: 8px; padding: 10px 16px; cursor: pointer; font-weight: 600; }
    .btn:disabled { background: #94a3b8; cursor: not-allowed; }
    .progress-bar { width: 100%; background: #e5e7eb; border-radius: 8px; overflow: hidden; height: 10px; margin: 8px 0; }
    .progress { height: 100%; background: linear-gradient(90deg, #2563eb, #22d3ee); width: 0%; transition: width 0.25s ease; }
    .status-list { margin: 8px 0; padding-left: 18px; color: #475569; }
    .tabs { display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap; border-bottom: 1px solid #e2e8f0; padding-bottom: 8px; }
    .tab { padding: 10px 16px; border-radius: 8px; background: #f3f4f6; color: #6b7280; cursor: pointer; font-weight: 600; transition: all 0.2s ease; border: 1px solid transparent; }
    .tab:hover { background: #e5e7eb; color: #374151; }
    .tab.active { background: #2563eb; color: #fff; border-color: #1d4ed8; box-shadow: 0 2px 4px rgba(37, 99, 235, 0.1); }
    pre { background: #0f172a; color: #e2e8f0; padding: 12px; border-radius: 8px; overflow-x: auto; }
    .badge { display: inline-block; padding: 4px 8px; border-radius: 12px; background: #e0f2fe; color: #0369a1; font-size: 12px; font-weight: 700; }
    .panel { border: 1px solid #e2e8f0; border-radius: 10px; padding: 12px; margin-bottom: 8px; background: #f8fafc; }
    .panel h4 { margin: 0 0 6px; }
    .divider { height: 1px; background: #e2e8f0; margin: 12px 0; }
    code.inline { background: #e2e8f0; padding: 2px 4px; border-radius: 4px; }

    /* ç»“æœå±•ç¤ºä¼˜åŒ–æ ·å¼ */
    .result-container { margin-top: 16px; }
    .result-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
    .result-title { font-size: 18px; font-weight: 600; color: #1f2937; margin: 0; }
    .confidence-bar { width: 100%; height: 8px; background: #e5e7eb; border-radius: 4px; overflow: hidden; margin: 8px 0; }
    .confidence-fill { height: 100%; border-radius: 4px; transition: width 0.3s ease; }
    .confidence-high { background: linear-gradient(90deg, #10b981, #059669); }
    .confidence-medium { background: linear-gradient(90deg, #f59e0b, #d97706); }
    .confidence-low { background: linear-gradient(90deg, #ef4444, #dc2626); }

    .result-content { padding: 0; }
    .result-section { margin-bottom: 16px; }
    .result-section:last-child { margin-bottom: 0; }
    .section-title { font-size: 14px; font-weight: 600; color: #374151; margin-bottom: 8px; display: flex; align-items: center; }
    .section-icon { margin-right: 8px; font-size: 16px; }
    .section-content { color: #4b5563; line-height: 1.6; padding-left: 24px; }

    .analysis-item { margin-bottom: 12px; padding: 12px; background: #f9fafb; border-radius: 6px; border-left: 3px solid #3b82f6; }
    .analysis-label { font-weight: 600; color: #1f2937; margin-bottom: 4px; }
    .analysis-text { color: #4b5563; line-height: 1.5; }

    .highlight { background: #fef3c7; padding: 2px 4px; border-radius: 3px; font-weight: 500; }
    .warning { background: #fee2e2; padding: 2px 4px; border-radius: 3px; font-weight: 500; color: #dc2626; }
    .success { background: #d1fae5; padding: 2px 4px; border-radius: 3px; font-weight: 500; color: #059669; }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
</head>
<body>
  <header>
    <h2>AI äº§å“æ–‡æ¡£å®¡æŸ¥ï¼ˆçº¯å‰ç«¯ç‰ˆæœ¬ï¼‰</h2>
  </header>
  <main>
    <section class="card">
      <h3>æ­¥éª¤ 1ï¼šé…ç½® API å¯†é’¥å¹¶ä¸Šä¼  PDF</h3>
      <div class="flex" style="margin-bottom: 8px;">
        <select id="apiProvider" style="padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; margin-right: 8px;">
          <option value="openai">OpenAI GPT-4o-mini</option>
          <option value="deepseek">DeepSeek</option>
          <option value="custom">è‡ªå®šä¹‰API</option>
        </select>
        <input type="password" id="apiKeyInput" placeholder="è¾“å…¥ API å¯†é’¥" style="flex: 1; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px;" />
        <button class="btn" id="saveKeyBtn">ä¿å­˜å¯†é’¥</button>
      </div>
      <div id="customApiSettings" style="display: none; margin-bottom: 8px;">
        <div class="flex">
          <input type="text" id="customApiUrl" placeholder="APIç«¯ç‚¹URL" style="flex: 1; padding: 6px; border: 1px solid #d1d5db; border-radius: 4px; margin-right: 4px;" />
          <input type="text" id="customModel" placeholder="æ¨¡å‹åç§°" value="gpt-4o-mini" style="flex: 1; padding: 6px; border: 1px solid #d1d5db; border-radius: 4px;" />
        </div>
      </div>
      <div class="flex">
        <input type="file" id="fileInput" accept="application/pdf" />
        <button class="btn" id="startBtn" disabled>å¼€å§‹åˆ†æ</button>
        <span id="fileInfo" class="badge">æœªé€‰æ‹©æ–‡ä»¶</span>
      </div>
      <div class="divider"></div>
      <div class="progress-bar"><div id="progress" class="progress"></div></div>
      <ul class="status-list" id="statusList"></ul>
    </section>

    <section class="card">
      <h3>æ­¥éª¤ 2ï¼šç»“æœé¢æ¿</h3>
      <div class="tabs" id="tabs"></div>
      <div id="resultPanel" class="panel">æš‚æ— ç»“æœï¼Œè¯·å…ˆä¸Šä¼ å¹¶åˆ†æã€‚</div>
      <div id="docStats" class="panel" style="display: none; margin-top: 12px;">
        <h4>æ–‡æ¡£å¤„ç†ç»Ÿè®¡</h4>
        <div style="display: flex; gap: 16px; flex-wrap: wrap;">
          <div class="badge" id="docLength">æ–‡æ¡£é•¿åº¦: --</div>
          <div class="badge" id="chunkCount">åˆ†å—æ•°é‡: --</div>
          <div class="badge" id="avgChunkSize">å¹³å‡å—å¤§å°: --</div>
        </div>
      </div>

      <div id="tokenUsage" class="panel" style="display: none; margin-top: 12px;">
        <h4>Token ä½¿ç”¨æƒ…å†µ</h4>
        <div style="display: flex; gap: 16px; flex-wrap: wrap;">
          <div class="badge" id="promptTokens">è¾“å…¥: --</div>
          <div class="badge" id="completionTokens">è¾“å‡º: --</div>
          <div class="badge" id="totalTokens">æ€»è®¡: --</div>
        </div>
      </div>
      <div class="divider"></div>
      <div class="flex">
        <button class="btn" id="testConnection">æµ‹è¯•è¿æ¥</button>
        <button class="btn" id="exportJson" disabled>å¯¼å‡º JSON</button>
        <button class="btn" id="copySummary" disabled>å¤åˆ¶æ‘˜è¦</button>
        <button class="btn" id="rerun" disabled>é‡æ–°åˆ†æ</button>
      </div>
    </section>

    <section class="card">
      <h3>API è¯·æ±‚ç¤ºä¾‹</h3>
      <pre id="apiRequestPreview"></pre>

      <h3>ç½‘ç»œè¯Šæ–­</h3>
      <div class="panel">
        <div class="flex" style="margin-bottom: 12px;">
          <button class="btn" id="testNetwork">æµ‹è¯•ç½‘ç»œè¿æ¥</button>
          <span id="networkStatus" class="badge">æœªæµ‹è¯•</span>
        </div>

        <p><strong>å¸¸è§ç½‘ç»œé—®é¢˜è§£å†³æ–¹æ¡ˆï¼š</strong></p>
        <ul>
          <li>ğŸ”¸ <strong>ä¸­å›½å¤§é™†ç”¨æˆ·</strong>ï¼šOpenAI APIå¯èƒ½è¢«å±è”½ï¼Œå»ºè®®ä½¿ç”¨VPN</li>
          <li>ğŸ”¸ <strong>VPNé€‰æ‹©</strong>ï¼šé¦™æ¸¯/æ–°åŠ å¡/æ—¥æœ¬/ç¾å›½è¥¿éƒ¨èŠ‚ç‚¹é€šå¸¸å¯ç”¨</li>
          <li>ğŸ”¸ <strong>é˜²ç«å¢™</strong>ï¼šæ£€æŸ¥æ˜¯å¦é˜»æ­¢äº†api.openai.com (443ç«¯å£)</li>
          <li>ğŸ”¸ <strong>ä»£ç†è®¾ç½®</strong>ï¼šæµè§ˆå™¨å¯èƒ½éœ€è¦é…ç½®ä»£ç†</li>
        </ul>

        <p><strong>æ›¿ä»£æ–¹æ¡ˆï¼š</strong></p>
        <ul>
          <li>ğŸ”¸ <strong>DeepSeek</strong>ï¼šå†…ç½®æ”¯æŒï¼Œæ— éœ€é¢å¤–é…ç½®</li>
          <li>ğŸ”¸ <strong>å…¶ä»–æœåŠ¡</strong>ï¼šæ–‡å¿ƒä¸€è¨€ã€æ™ºè°±AIã€é€šä¹‰åƒé—®ç­‰</li>
          <li>ğŸ”¸ <strong>æœ¬åœ°éƒ¨ç½²</strong>ï¼šOllama + å¼€æºæ¨¡å‹</li>
          <li>ğŸ”¸ <strong>ä»£ç†æœåŠ¡</strong>ï¼šéƒ¨ç½²åç«¯ä¸­è½¬APIè¯·æ±‚</li>
        </ul>
      </div>
    </section>
  </main>

  <script>
    // PDF.js åˆå§‹åŒ–
    // è®¾ç½®PDF.js workerè·¯å¾„ï¼Œå¸¦å¤‡ç”¨æ–¹æ¡ˆ
    try {
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.6.82/build/pdf.worker.min.js';
    } catch (e) {
      console.warn('Setting PDF.js worker failed:', e);
      try {
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@4.6.82/build/pdf.worker.min.js';
      } catch (e2) {
        console.error('PDF.js worker setup failed completely:', e2);
      }
    }

    // ç­‰å¾…DOMåŠ è½½å®Œæˆ
    document.addEventListener('DOMContentLoaded', function() {
      console.log('DOM loaded, initializing application...');

      // PDF.js åˆå§‹åŒ–
      try {
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        console.log('PDF.js worker configured successfully');
      } catch (e) {
        console.warn('Setting PDF.js worker failed:', e);
      }

      initializeApp();
    });

    // å°†æ‰€æœ‰åˆå§‹åŒ–ä»£ç ç§»åˆ°è¿™ä¸ªå‡½æ•°ä¸­
    function initializeApp() {
      console.log('Initializing application...');

      const fileInput = document.getElementById('fileInput');
      const startBtn = document.getElementById('startBtn');
      const statusList = document.getElementById('statusList');
      const progressEl = document.getElementById('progress');
      const tabsEl = document.getElementById('tabs');
      const resultPanel = document.getElementById('resultPanel');
      const fileInfo = document.getElementById('fileInfo');
      const apiRequestPreview = document.getElementById('apiRequestPreview');
      const exportJsonBtn = document.getElementById('exportJson');
      const copySummaryBtn = document.getElementById('copySummary');
      const rerunBtn = document.getElementById('rerun');
      const testConnectionBtn = document.getElementById('testConnection');
      const testNetworkBtn = document.getElementById('testNetwork');
      const networkStatus = document.getElementById('networkStatus');
      const apiProvider = document.getElementById('apiProvider');
      const customApiSettings = document.getElementById('customApiSettings');
      const customApiUrl = document.getElementById('customApiUrl');
      const customModel = document.getElementById('customModel');
      const apiKeyInput = document.getElementById('apiKeyInput');
      const saveKeyBtn = document.getElementById('saveKeyBtn');

      let extractedText = '';
      let lastResult = null;
      let currentFile = null;
      let apiKey = localStorage.getItem('openai_api_key') || '';

      // åˆå§‹åŒ–APIè®¾ç½®
      const savedProvider = localStorage.getItem('api_provider') || 'openai';
      const savedApiUrl = localStorage.getItem('custom_api_url') || '';
      const savedModel = localStorage.getItem('custom_model') || 'gpt-4o-mini';

      apiProvider.value = savedProvider;
      customApiUrl.value = savedApiUrl;
      customModel.value = savedModel;

      // æ˜¾ç¤º/éšè—è‡ªå®šä¹‰APIè®¾ç½®ï¼Œå¹¶è‡ªåŠ¨å¡«å……é¢„è®¾å€¼
      function updateApiSettings() {
        const provider = apiProvider.value;
        if (provider === 'deepseek') {
          customApiUrl.value = 'https://api.deepseek.com/v1/chat/completions';
          customModel.value = 'deepseek-chat';
          customApiSettings.style.display = 'none'; // DeepSeekä½¿ç”¨å›ºå®šé…ç½®
        } else if (provider === 'custom') {
          customApiSettings.style.display = 'block';
        } else {
          customApiSettings.style.display = 'none';
        }
      }

      apiProvider.addEventListener('change', function() {
        localStorage.setItem('api_provider', this.value);
        updateApiSettings();
        // åˆ‡æ¢APIæä¾›å•†æ—¶å¯ç”¨ä¿å­˜æŒ‰é’®
        if (saveKeyBtn.disabled) {
          saveKeyBtn.textContent = 'ä¿å­˜è®¾ç½®';
          saveKeyBtn.disabled = false;
        }
      });

      updateApiSettings();

      // åˆå§‹åŒ–APIå¯†é’¥è¾“å…¥æ¡†
      apiKeyInput.value = apiKey;
      if (apiKey) {
        saveKeyBtn.textContent = 'å·²ä¿å­˜';
        saveKeyBtn.disabled = true;
      }

      // å½“ç”¨æˆ·ä¿®æ”¹APIå¯†é’¥è¾“å…¥æ¡†æ—¶ï¼Œå¯ç”¨ä¿å­˜æŒ‰é’®
      apiKeyInput.addEventListener('input', () => {
        if (saveKeyBtn.disabled) {
          saveKeyBtn.textContent = 'ä¿å­˜å¯†é’¥';
          saveKeyBtn.disabled = false;
        }
      });

      // å½“ç”¨æˆ·ä¿®æ”¹è‡ªå®šä¹‰APIè®¾ç½®æ—¶ï¼Œä¹Ÿå¯ç”¨ä¿å­˜æŒ‰é’®
      customApiUrl.addEventListener('input', () => {
        if (saveKeyBtn.disabled) {
          saveKeyBtn.textContent = 'ä¿å­˜è®¾ç½®';
          saveKeyBtn.disabled = false;
        }
      });

      customModel.addEventListener('input', () => {
        if (saveKeyBtn.disabled) {
          saveKeyBtn.textContent = 'ä¿å­˜è®¾ç½®';
          saveKeyBtn.disabled = false;
        }
      });

      // åˆå§‹åŒ–æŒ‰é’®çŠ¶æ€
      startBtn.disabled = !canStartAnalysis();

    const steps = [
      { label: 'è§£æ PDF æ–‡æ¡£', progress: 8 },
      { label: 'AI åˆ†ææ–‡æ¡£ç»“æ„', progress: 15 },
      { label: 'AI åˆ†æä¸­ - è®¾è®¡ç¼ºé™·æ£€æŸ¥', progress: 40 },
      { label: 'AI åˆ†æä¸­ - é€»è¾‘ä¸€è‡´æ€§åˆ†æ', progress: 70 },
      { label: 'AI åˆ†æä¸­ - é£é™©è¯„ä¼°', progress: 95 },
      { label: 'ç”Ÿæˆå¯è§†åŒ–æŠ¥å‘Š', progress: 100 },
    ];

    // AIæ™ºèƒ½æ–‡æ¡£åˆ†æå’Œåˆ†å—ç­–ç•¥
    const documentProcessor = {
      // åˆ†é˜¶æ®µAIæ™ºèƒ½æ–‡æ¡£åˆ†æï¼ˆä¸€æ¬¡å¯¹è¯å®Œæˆæ‰€æœ‰æ­¥éª¤ï¼‰
      async performStagedAnalysis(text) {
        const provider = apiProvider.value;
        let apiUrl = 'https://api.openai.com/v1/chat/completions';
        let model = 'gpt-4o-mini';

        console.log(`performStagedAnalysis: provider=${provider}`);

        if (provider === 'deepseek') {
          apiUrl = 'https://api.deepseek.com/v1/chat/completions';
          model = 'deepseek-chat';
          console.log(`DeepSeek selected: apiUrl=${apiUrl}, model=${model}`);
        } else if (provider === 'custom') {
          apiUrl = customApiUrl.value;
          model = customModel.value;
          console.log(`Custom API selected: apiUrl=${apiUrl}, model=${model}`);
        } else {
          console.log(`OpenAI selected: apiUrl=${apiUrl}, model=${model}`);
        }

        // ç¬¬ä¸€é˜¶æ®µï¼šæ–‡æ¡£ç»“æ„åˆ†æ
        const structurePrompt = `è¯·ä½œä¸ºä¸“ä¸šçš„äº§å“æ–‡æ¡£åˆ†æå¸ˆï¼Œæ·±åº¦åˆ†æä»¥ä¸‹æ–‡æ¡£å†…å®¹ï¼Œä¸ºåç»­ç²¾ç¡®çš„è´¨é‡åˆ†æåšå‡†å¤‡ã€‚è¯·é‡ç‚¹å…³æ³¨æ–‡æ¡£çš„é€»è¾‘ç»“æ„ã€å†…å®¹å®Œæ•´æ€§å’Œæ½œåœ¨é—®é¢˜ç‚¹ã€‚

åˆ†æè¦æ±‚ï¼š
1. è¯†åˆ«æ–‡æ¡£çš„æ ¸å¿ƒç« èŠ‚å’Œé€»è¾‘å±‚æ¬¡ç»“æ„
2. å°†å†…å®¹åˆ’åˆ†ä¸ºæœ‰æ„ä¹‰çš„åŠŸèƒ½æ¨¡å—æˆ–ä¸»é¢˜æ®µè½
3. ä¸ºæ¯ä¸ªæ®µè½æä¾›ç²¾ç¡®çš„åˆ†ç±»æ ‡ç­¾
4. è¯„ä¼°æ®µè½å¯¹ä¸åŒè´¨é‡åˆ†æç»´åº¦çš„ç›¸å…³æ€§ï¼ˆ0-10åˆ†ï¼‰
5. è€ƒè™‘æ–‡æ¡£çš„ä¸Šä¸‹æ–‡å…³ç³»å’Œä¾èµ–æ€§

æ–‡æ¡£å†…å®¹ï¼š
${text.substring(0, 10000)}

è¯·è¿”å›ç²¾ç¡®çš„JSONç»“æ„ï¼š
{
  "document_summary": "æ–‡æ¡£æ•´ä½“æ‘˜è¦ï¼ˆ150å­—ä»¥å†…ï¼ŒåŒ…å«æ–‡æ¡£ç±»å‹ã€ä¸»è¦åŠŸèƒ½ã€å…³é”®ç‰¹ç‚¹ï¼‰",
  "document_type": "äº§å“éœ€æ±‚æ–‡æ¡£|æŠ€æœ¯è®¾è®¡æ–‡æ¡£|ç”¨æˆ·æ‰‹å†Œ|å…¶ä»–",
  "sections": [
    {
      "id": "section_1",
      "title": "ç²¾ç¡®çš„æ®µè½æ ‡é¢˜",
      "content": "æ®µè½çš„å®Œæ•´åŸæ–‡å†…å®¹",
      "category": "åŠŸèƒ½éœ€æ±‚|è®¾è®¡è§„èŒƒ|æŠ€æœ¯æ¶æ„|ç”¨æˆ·ä½“éªŒ|æ•°æ®æ¨¡å‹|å®‰å…¨è¦æ±‚|æ€§èƒ½æŒ‡æ ‡|æµ‹è¯•ç”¨ä¾‹|éƒ¨ç½²è¯´æ˜|ç»´æŠ¤æŒ‡å—|å…¶ä»–",
      "hierarchy_level": 1-5,
      "word_count": 0,
      "relevance": {
        "è®¾è®¡ç¼ºé™·æ£€æŸ¥": "è¯„ä¼°è¯¥æ®µè½åŒ…å«UI/UXè®¾è®¡ã€äº¤äº’é€»è¾‘ã€å¯ç”¨æ€§é—®é¢˜çš„ç¨‹åº¦ï¼ˆ0-10ï¼‰",
        "é€»è¾‘ä¸€è‡´æ€§åˆ†æ": "è¯„ä¼°è¯¥æ®µè½æ¶‰åŠä¸šåŠ¡é€»è¾‘ã€æ•°æ®æµã€è§„åˆ™ä¸€è‡´æ€§çš„ç¨‹åº¦ï¼ˆ0-10ï¼‰",
        "é£é™©è¯„ä¼°": "è¯„ä¼°è¯¥æ®µè½æ¶‰åŠæŠ€æœ¯é£é™©ã€ä¸šåŠ¡é£é™©ã€å®‰å…¨éšæ‚£çš„ç¨‹åº¦ï¼ˆ0-10ï¼‰"
      },
      "tags": ["æ ‡ç­¾1", "æ ‡ç­¾2"]
    }
  ],
  "metadata": {
    "total_sections": 0,
    "total_length": 0,
    "document_structure": "å±‚æ¬¡åŒ–|æ¨¡å—åŒ–|çº¿æ€§",
    "estimated_complexity": "ä½|ä¸­|é«˜"
  }
}`;

        const messages = [
          { role: 'system', content: 'ä½ æ˜¯ä¸“ä¸šçš„äº§å“æ–‡æ¡£è´¨é‡åˆ†æåŠ©æ‰‹ã€‚è¯·æŒ‰é˜¶æ®µé€æ­¥åˆ†ææ–‡æ¡£ï¼Œæä¾›è¯¦ç»†ã€å‡†ç¡®çš„åˆ†æç»“æœã€‚' },
          { role: 'user', content: `é˜¶æ®µ1ï¼šæ–‡æ¡£ç»“æ„åˆ†æ\n\n${structurePrompt}` }
        ];

        try {
          // ç¬¬ä¸€é˜¶æ®µï¼šè·å–æ–‡æ¡£ç»“æ„
          console.log('å¼€å§‹é˜¶æ®µ1ï¼šæ–‡æ¡£ç»“æ„åˆ†æ');
          const structureResponse = await this.callApiWithMessages(apiUrl, model, messages);
          const structureData = this.extractJsonFromResponse(structureResponse.content);
          const processedDoc = this.validateAndFixResultStructure(structureData, text);

          // ç¬¬äºŒé˜¶æ®µï¼šè®¾è®¡ç¼ºé™·æ£€æŸ¥
          console.log('å¼€å§‹é˜¶æ®µ2ï¼šè®¾è®¡ç¼ºé™·æ£€æŸ¥');
          const designSections = this.getRelevantSections(processedDoc, { key: 'è®¾è®¡ç¼ºé™·æ£€æŸ¥' });
          const designContent = this.generateContentForAnalysis(designSections, 3000);

          messages.push({ role: 'assistant', content: structureResponse.content });
          messages.push({
            role: 'user',
            content: `é˜¶æ®µ2ï¼šè®¾è®¡ç¼ºé™·æ£€æŸ¥

åŸºäºå·²åˆ†æçš„æ–‡æ¡£ç»“æ„ï¼Œè¯·å¯¹è®¾è®¡ç¼ºé™·è¿›è¡Œæ·±å…¥åˆ†æï¼š

åˆ†æå†…å®¹ï¼š
${designContent}

è¯·é‡ç‚¹å…³æ³¨ï¼š
1. UI/UXè®¾è®¡é—®é¢˜
2. äº¤äº’é€»è¾‘ç¼ºé™·
3. ç”¨æˆ·ä½“éªŒé—®é¢˜
4. ç•Œé¢ä¸€è‡´æ€§é—®é¢˜

è¯·è¿”å›JSONæ ¼å¼ï¼š
{
  "result": "è¯¦ç»†çš„è®¾è®¡ç¼ºé™·åˆ†æå†…å®¹ï¼ŒåŒ…æ‹¬å‘ç°çš„é—®é¢˜å’Œæ”¹è¿›å»ºè®®"
}`
          });

          const designResponse = await this.callApiWithMessages(apiUrl, model, messages);

          // ç¬¬ä¸‰é˜¶æ®µï¼šé€»è¾‘ä¸€è‡´æ€§åˆ†æ
          console.log('å¼€å§‹é˜¶æ®µ3ï¼šé€»è¾‘ä¸€è‡´æ€§åˆ†æ');
          const logicSections = this.getRelevantSections(processedDoc, { key: 'é€»è¾‘ä¸€è‡´æ€§åˆ†æ' });
          const logicContent = this.generateContentForAnalysis(logicSections, 2500);

          messages.push({ role: 'assistant', content: designResponse.content });
          messages.push({
            role: 'user',
            content: `é˜¶æ®µ3ï¼šé€»è¾‘ä¸€è‡´æ€§åˆ†æ

åŸºäºå·²åˆ†æçš„æ–‡æ¡£ç»“æ„å’Œè®¾è®¡ç¼ºé™·æ£€æŸ¥ç»“æœï¼Œè¯·åˆ†ææ–‡æ¡£çš„é€»è¾‘ä¸€è‡´æ€§ï¼š

åˆ†æå†…å®¹ï¼š
${logicContent}

è¯·é‡ç‚¹å…³æ³¨ï¼š
1. ä¸šåŠ¡é€»è¾‘çš„è¿è´¯æ€§
2. æ•°æ®æµçš„ä¸€è‡´æ€§
3. è§„åˆ™å’Œçº¦æŸçš„ç»Ÿä¸€æ€§
4. æ¦‚å¿µå®šä¹‰çš„ä¸€è‡´æ€§

è¯·è¿”å›JSONæ ¼å¼ï¼š
{
  "result": "è¯¦ç»†çš„é€»è¾‘ä¸€è‡´æ€§åˆ†æå†…å®¹ï¼ŒåŒ…æ‹¬å‘ç°çš„çŸ›ç›¾å’Œä¸ä¸€è‡´é—®é¢˜"
}`
          });

          const logicResponse = await this.callApiWithMessages(apiUrl, model, messages);

          // ç¬¬å››é˜¶æ®µï¼šé£é™©è¯„ä¼°
          console.log('å¼€å§‹é˜¶æ®µ4ï¼šé£é™©è¯„ä¼°');
          const riskSections = this.getRelevantSections(processedDoc, { key: 'é£é™©è¯„ä¼°' });
          const riskContent = this.generateContentForAnalysis(riskSections, 2000);

          messages.push({ role: 'assistant', content: logicResponse.content });
          messages.push({
            role: 'user',
            content: `é˜¶æ®µ4ï¼šé£é™©è¯„ä¼°

åŸºäºå‰é¢æ‰€æœ‰åˆ†æç»“æœï¼Œè¯·è¿›è¡Œå…¨é¢çš„é£é™©è¯„ä¼°ï¼š

åˆ†æå†…å®¹ï¼š
${riskContent}

è¯·é‡ç‚¹å…³æ³¨ï¼š
1. æŠ€æœ¯å®ç°é£é™©
2. ä¸šåŠ¡é€»è¾‘é£é™©
3. å®‰å…¨å’Œåˆè§„é£é™©
4. æ€§èƒ½å’Œæ‰©å±•æ€§é£é™©
5. ç»´æŠ¤å’Œè¿è¥é£é™©

è¯·è¿”å›JSONæ ¼å¼ï¼š
{
  "result": "è¯¦ç»†çš„é£é™©è¯„ä¼°å†…å®¹ï¼ŒåŒ…æ‹¬é£é™©ç­‰çº§ã€å…·ä½“é£é™©æè¿°å’Œç¼“è§£æªæ–½å»ºè®®"
}`
          });

          const riskResponse = await this.callApiWithMessages(apiUrl, model, messages);

          // è§£æå„é˜¶æ®µç»“æœ
          const designResult = this.extractJsonFromResponse(designResponse.content);
          const logicResult = this.extractJsonFromResponse(logicResponse.content);
          const riskResult = this.extractJsonFromResponse(riskResponse.content);

          return {
            processedDoc,
            usage: riskResponse.usage, // ä½¿ç”¨æœ€åä¸€æ¬¡è°ƒç”¨çš„usage
            documentStructure: processedDoc.sections.length > 0
              ? `ğŸ“„ æ–‡æ¡£æ‘˜è¦ï¼š${processedDoc.document_summary}\n\nğŸ“Š åˆ†æç»“æœï¼šå…±è¯†åˆ«${processedDoc.sections.length}ä¸ªæ®µè½\n\nä¸»è¦æ®µè½ï¼š\n${
                  processedDoc.sections.slice(0, 5).map(s => `â€¢ ${s.title} (${s.category})`).join('\n')
                }${processedDoc.sections.length > 5 ? `\n...è¿˜æœ‰${processedDoc.sections.length - 5}ä¸ªæ®µè½` : ''}`
              : `ğŸ“„ æ–‡æ¡£æ‘˜è¦ï¼š${processedDoc.document_summary}\n\nâš ï¸ æ–‡æ¡£æ®µè½è¯†åˆ«è¯¦æƒ…ï¼š\nâ€¢ æ–‡æ¡£æ€»å­—ç¬¦æ•°ï¼š${processedDoc.metadata?.total_length || 0}\nâ€¢ è¯†åˆ«æ®µè½æ•°ï¼š0\nâ€¢ å¤„ç†æ–¹æ³•ï¼šä¼ ç»Ÿåˆ†å—\n\nğŸ” å¯èƒ½çš„åŸå› ï¼š\nâ€¢ PDFæ–‡æ¡£ä¸»è¦æ˜¯å›¾ç‰‡æˆ–æ‰«æä»¶\nâ€¢ æ–‡æœ¬å†…å®¹æ ¼å¼ç‰¹æ®Šï¼ˆæ— æ˜ç¡®æ®µè½åˆ†éš”ï¼‰\nâ€¢ æ–‡æ¡£å†…å®¹è¿‡äºç®€çŸ­æˆ–ä¸é€‚åˆç»“æ„åŒ–åˆ†æ\n\nğŸ’¡ å»ºè®®ï¼š\nâ€¢ æ£€æŸ¥PDFæ˜¯å¦åŒ…å«å¯æœç´¢æ–‡æœ¬\nâ€¢ å°è¯•ä½¿ç”¨å…¶ä»–æ–‡æ¡£æ ¼å¼\nâ€¢ å¦‚æœæ˜¯å›¾ç‰‡PDFï¼Œå¯èƒ½éœ€è¦OCRå¤„ç†`,
            'è®¾è®¡ç¼ºé™·æ£€æŸ¥': designResult.result || designResponse.content,
            'é€»è¾‘ä¸€è‡´æ€§åˆ†æ': logicResult.result || logicResponse.content,
            'é£é™©è¯„ä¼°': riskResult.result || riskResponse.content
          };

        } catch (error) {
          console.error('åˆ†é˜¶æ®µåˆ†æå¤±è´¥:', error);
          // é™çº§åˆ°ä¼ ç»Ÿåˆ†ææ–¹æ³•
          return this.fallbackStagedAnalysis(text);
        }
      },

      // è°ƒç”¨APIçš„æ–¹æ³•ï¼ˆæ”¯æŒæ¶ˆæ¯å†å²ï¼‰
      async callApiWithMessages(apiUrl, model, messages) {
        console.log(`callApiWithMessages called with model: ${model}, apiUrl: ${apiUrl}`);
        const provider = apiProvider.value;
        let payload;

        if (provider === 'deepseek') {
          // DeepSeek APIçš„ç‰¹æ®Šé…ç½®
          payload = {
            model: model,
            messages: messages,
            max_tokens: 4000,
            temperature: 0.7, // DeepSeekå¯èƒ½ä¸æ”¯æŒ0.2
          };
        } else {
          // OpenAIå’Œå…¶ä»–å…¼å®¹API
          payload = {
            model: model,
            temperature: 0.2,
            messages: messages,
            max_tokens: 4000
          };
        }

        const headers = {
          'Content-Type': 'application/json',
        };

        // æ ¹æ®æä¾›å•†è®¾ç½®è®¤è¯å¤´
        if (provider === 'custom') {
          if (apiKey) {
            headers['Authorization'] = `Bearer ${apiKey}`;
          }
        } else {
          headers['Authorization'] = `Bearer ${apiKey}`;
        }

        console.log(`Sending API request to ${apiUrl} with payload:`, JSON.stringify(payload, null, 2));

        const response = await fetch(apiUrl, {
          method: 'POST',
          headers: headers,
          body: JSON.stringify(payload),
        });

        if (!response.ok) {
          let errorText = 'Unknown error';
          try {
            errorText = await response.text();
          } catch (e) {
            errorText = 'æ— æ³•è¯»å–é”™è¯¯è¯¦æƒ…';
          }
          console.error('API Error:', response.status, errorText);
          throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status} - ${errorText}`);
        }

        const data = await response.json();
        return {
          content: data.choices[0].message.content,
          usage: data.usage
        };
      },

      // ä»å“åº”ä¸­æå–JSONç»“æœ
      extractJsonFromResponse(content) {
        console.log('extractJsonFromResponse input length:', content.length);
        console.log('extractJsonFromResponse input preview:', content.substring(0, 200));
        try {
          let cleaned = content.trim();

          // å¤šç§æ–¹å¼æ¸…ç†markdownä»£ç å—
          // 1. ç§»é™¤```jsonæ ‡è®°
          cleaned = cleaned.replace(/```json\s*/gi, '').replace(/```\s*$/g, '');
          // 2. ç§»é™¤å…¶ä»–ä»£ç å—æ ‡è®°
          cleaned = cleaned.replace(/```\w*\s*/gi, '').replace(/```\s*$/g, '');
          // 3. ç§»é™¤çº¯```æ ‡è®°
          cleaned = cleaned.replace(/```\s*/g, '');
          // 4. æ¸…ç†å‰åçš„ç©ºç™½å’Œæ¢è¡Œ
          cleaned = cleaned.trim();

          console.log('extractJsonFromResponse cleaned length:', cleaned.length);
          console.log('extractJsonFromResponse cleaned preview:', cleaned.substring(0, 200));

          // å°è¯•æ‰¾åˆ°JSONçš„å¼€å§‹ä½ç½®
          let jsonStart = 0;
          const firstBrace = cleaned.indexOf('{');
          const firstBracket = cleaned.indexOf('[');

          if (firstBrace >= 0 || firstBracket >= 0) {
            if (firstBrace >= 0 && (firstBracket === -1 || firstBrace < firstBracket)) {
              jsonStart = firstBrace;
            } else if (firstBracket >= 0) {
              jsonStart = firstBracket;
            }
          }

          if (jsonStart > 0) {
            cleaned = cleaned.substring(jsonStart);
          }

          // æŸ¥æ‰¾JSONç»“æŸä½ç½®ï¼ˆåŒ¹é…çš„æ‹¬å·ï¼‰
          let braceCount = 0;
          let bracketCount = 0;
          let inString = false;
          let escapeNext = false;
          let endPos = -1;

          for (let i = 0; i < cleaned.length; i++) {
            const char = cleaned[i];

            if (escapeNext) {
              escapeNext = false;
              continue;
            }

            if (char === '\\') {
              escapeNext = true;
              continue;
            }

            if (char === '"') {
              inString = !inString;
              continue;
            }

            if (!inString) {
              if (char === '{') braceCount++;
              else if (char === '}') braceCount--;
              else if (char === '[') bracketCount++;
              else if (char === ']') bracketCount--;

              // å½“æ‰€æœ‰æ‹¬å·éƒ½åŒ¹é…æ—¶ï¼Œæ‰¾åˆ°ç»“æŸä½ç½®
              if (braceCount === 0 && bracketCount === 0 && (char === '}' || char === ']')) {
                endPos = i + 1;
                break;
              }
            }
          }

          if (endPos > 0) {
            cleaned = cleaned.substring(0, endPos);
          }

          // æœ€åæ¸…ç†ä¸€æ¬¡
          cleaned = cleaned.trim();

          console.log('extractJsonFromResponse final length:', cleaned.length);
          console.log('extractJsonFromResponse final preview:', cleaned.substring(0, 200));
          console.log('extractJsonFromResponse final end:', cleaned.substring(cleaned.length - 200));

          return JSON.parse(cleaned);
        } catch (e) {
          console.warn('JSONæå–å¤±è´¥ï¼Œè¿”å›åŸå§‹å†…å®¹:', e);
          console.warn('Error details:', e.message);
          console.warn('Failed content preview:', content.substring(6400, 6500)); // é”™è¯¯ä½ç½®é™„è¿‘çš„å†…å®¹
          return { result: content };
        }
      },

      // é™çº§åˆ†ææ–¹æ³•ï¼ˆå½“åˆ†é˜¶æ®µåˆ†æå¤±è´¥æ—¶ä½¿ç”¨ï¼‰
      async fallbackStagedAnalysis(text) {
        console.log('ä½¿ç”¨é™çº§åˆ†ææ–¹æ³•');

        // å…ˆè¿›è¡Œæ–‡æ¡£ç»“æ„åˆ†æ
        const processedDoc = await this.analyzeDocumentStructure(text);

        // è·å–æ­£ç¡®çš„æ¨¡å‹é…ç½®
        const provider = apiProvider.value;
        let model = 'gpt-4o-mini'; // é»˜è®¤OpenAI
        let temperature = 0.2;

        if (provider === 'deepseek') {
          model = 'deepseek-chat';
          temperature = 0.7;
        } else if (provider === 'custom') {
          model = customModel.value;
        }

        // ç„¶åé€ä¸ªè¿›è¡Œåˆ†æï¼ˆä½¿ç”¨åŸæ¥çš„æ–¹æ³•ï¼‰
        const results = {
          processedDoc,
          documentStructure: `ğŸ“„ æ–‡æ¡£æ‘˜è¦ï¼š${processedDoc.document_summary}\n\nğŸ“Š åˆ†æç»“æœï¼šå…±è¯†åˆ«${processedDoc.sections.length}ä¸ªæ®µè½ï¼ŒåŒ…æ‹¬ï¼š\n${
            processedDoc.sections.map(s => `â€¢ ${s.title} (${s.category})`).join('\n')
          }`
        };

        // é€ä¸ªåˆ†æ
        for (const analysisType of analysisTypes) {
          try {
            const sections = this.getRelevantSections(processedDoc, analysisType);
            const content = this.generateContentForAnalysis(sections, analysisType.maxContentLength);

            const payload = {
              model: model,
              temperature: temperature,
              messages: [
                { role: 'system', content: 'ä½ æ˜¯äº§å“æ–‡æ¡£å®¡æŸ¥åŠ©æ‰‹ï¼Œè¯·åªè¾“å‡ºçº¯JSONæ ¼å¼ï¼Œä¸è¦åŒ…å«ä»»ä½•markdownä»£ç å—ã€‚' },
                { role: 'user', content: `${analysisType.prompt}\n\næ–‡æ¡£ç‰‡æ®µ:\n${content}\n\nè¯·è¿”å›ï¼š{"result": "è¯¦ç»†åˆ†æå†…å®¹"}` }
              ]
            };

            const response = await this.callApiWithPayload(payload);
            const parsed = this.extractJsonFromResponse(response.content);

            results[analysisType.key] = parsed.result || response.content;
            if (response.usage) {
              results.usage = response.usage;
            }
          } catch (e) {
            results[analysisType.key] = `åˆ†æå¤±è´¥: ${e.message}`;
          }
        }

        return results;
      },

      // è°ƒç”¨APIçš„æ–¹æ³•ï¼ˆå…¼å®¹åŸæœ‰payloadæ ¼å¼ï¼‰
      async callApiWithPayload(payload) {
        const provider = apiProvider.value;
        let apiUrl = 'https://api.openai.com/v1/chat/completions';
        let requestPayload = { ...payload };

        if (provider === 'deepseek') {
          apiUrl = 'https://api.deepseek.com/v1/chat/completions';
          // DeepSeekå¯èƒ½ä¸æ”¯æŒæŸäº›å‚æ•°ï¼Œè°ƒæ•´payload
          requestPayload = {
            model: payload.model,
            messages: payload.messages,
            max_tokens: payload.max_tokens || 4000,
            // ç§»é™¤å¯èƒ½ä¸æ”¯æŒçš„å‚æ•°
            temperature: payload.temperature || 0.7,
          };
        } else if (provider === 'custom') {
          apiUrl = customApiUrl.value;
          // è‡ªå®šä¹‰APIä¿æŒåŸå§‹payload
          requestPayload = payload;
        }

        const headers = {
          'Content-Type': 'application/json',
        };

        // æ ¹æ®æä¾›å•†è®¾ç½®è®¤è¯å¤´
        if (provider === 'custom') {
          // è‡ªå®šä¹‰APIå¯èƒ½ä½¿ç”¨ä¸åŒçš„è®¤è¯æ–¹å¼
          if (apiKey) {
            headers['Authorization'] = `Bearer ${apiKey}`;
          }
        } else {
          // OpenAIå’ŒDeepSeekæ ‡å‡†è®¤è¯
          headers['Authorization'] = `Bearer ${apiKey}`;
        }

        console.log(`callApiWithPayload sending request to ${apiUrl} with payload:`, JSON.stringify(requestPayload, null, 2));

        const response = await fetch(apiUrl, {
          method: 'POST',
          headers: headers,
          body: JSON.stringify(requestPayload),
        });

        if (!response.ok) {
          let errorText = 'Unknown error';
          try {
            errorText = await response.text();
          } catch (e) {
            errorText = 'æ— æ³•è¯»å–é”™è¯¯è¯¦æƒ…';
          }
          console.error('API Error:', response.status, errorText);
          throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status} - ${errorText}`);
        }

        const data = await response.json();
        return {
          content: data.choices[0].message.content,
          usage: data.usage
        };
      },

      // ä½¿ç”¨AIåˆ†ææ–‡æ¡£ç»“æ„å¹¶åˆ†å—
      async analyzeDocumentStructure(text) {
        const analysisPrompt = `è¯·ä½œä¸ºä¸“ä¸šçš„äº§å“æ–‡æ¡£åˆ†æå¸ˆï¼Œæ·±åº¦åˆ†æä»¥ä¸‹æ–‡æ¡£å†…å®¹ï¼Œä¸ºåç»­ç²¾ç¡®çš„è´¨é‡åˆ†æåšå‡†å¤‡ã€‚è¯·é‡ç‚¹å…³æ³¨æ–‡æ¡£çš„é€»è¾‘ç»“æ„ã€å†…å®¹å®Œæ•´æ€§å’Œæ½œåœ¨é—®é¢˜ç‚¹ã€‚

åˆ†æè¦æ±‚ï¼š
1. è¯†åˆ«æ–‡æ¡£çš„æ ¸å¿ƒç« èŠ‚å’Œé€»è¾‘å±‚æ¬¡ç»“æ„
2. å°†å†…å®¹åˆ’åˆ†ä¸ºæœ‰æ„ä¹‰çš„åŠŸèƒ½æ¨¡å—æˆ–ä¸»é¢˜æ®µè½
3. ä¸ºæ¯ä¸ªæ®µè½æä¾›ç²¾ç¡®çš„åˆ†ç±»æ ‡ç­¾
4. è¯„ä¼°æ®µè½å¯¹ä¸åŒè´¨é‡åˆ†æç»´åº¦çš„ç›¸å…³æ€§ï¼ˆ0-10åˆ†ï¼‰
5. è€ƒè™‘æ–‡æ¡£çš„ä¸Šä¸‹æ–‡å…³ç³»å’Œä¾èµ–æ€§

æ–‡æ¡£å†…å®¹ï¼š
${text.substring(0, 10000)}

è¯·è¿”å›ç²¾ç¡®çš„JSONç»“æ„ï¼š
{
  "document_summary": "æ–‡æ¡£æ•´ä½“æ‘˜è¦ï¼ˆ150å­—ä»¥å†…ï¼ŒåŒ…å«æ–‡æ¡£ç±»å‹ã€ä¸»è¦åŠŸèƒ½ã€å…³é”®ç‰¹ç‚¹ï¼‰",
  "document_type": "äº§å“éœ€æ±‚æ–‡æ¡£|æŠ€æœ¯è®¾è®¡æ–‡æ¡£|ç”¨æˆ·æ‰‹å†Œ|å…¶ä»–",
  "sections": [
    {
      "id": "section_1",
      "title": "ç²¾ç¡®çš„æ®µè½æ ‡é¢˜",
      "content": "æ®µè½çš„å®Œæ•´åŸæ–‡å†…å®¹",
      "category": "åŠŸèƒ½éœ€æ±‚|è®¾è®¡è§„èŒƒ|æŠ€æœ¯æ¶æ„|ç”¨æˆ·ä½“éªŒ|æ•°æ®æ¨¡å‹|å®‰å…¨è¦æ±‚|æ€§èƒ½æŒ‡æ ‡|æµ‹è¯•ç”¨ä¾‹|éƒ¨ç½²è¯´æ˜|ç»´æŠ¤æŒ‡å—|å…¶ä»–",
      "hierarchy_level": 1-5,
      "parent_section": "çˆ¶æ®µè½IDï¼ˆå¦‚æœæœ‰ï¼‰",
      "word_count": 0,
      "relevance": {
        "è®¾è®¡ç¼ºé™·æ£€æŸ¥": "è¯„ä¼°è¯¥æ®µè½åŒ…å«UI/UXè®¾è®¡ã€äº¤äº’é€»è¾‘ã€å¯ç”¨æ€§é—®é¢˜çš„ç¨‹åº¦ï¼ˆ0-10ï¼‰",
        "é€»è¾‘ä¸€è‡´æ€§åˆ†æ": "è¯„ä¼°è¯¥æ®µè½æ¶‰åŠä¸šåŠ¡é€»è¾‘ã€æ•°æ®æµã€è§„åˆ™ä¸€è‡´æ€§çš„ç¨‹åº¦ï¼ˆ0-10ï¼‰",
        "é£é™©è¯„ä¼°": "è¯„ä¼°è¯¥æ®µè½æ¶‰åŠæŠ€æœ¯é£é™©ã€ä¸šåŠ¡é£é™©ã€å®‰å…¨éšæ‚£çš„ç¨‹åº¦ï¼ˆ0-10ï¼‰"
      },
      "tags": ["æ ‡ç­¾1", "æ ‡ç­¾2"],
      "dependencies": ["ç›¸å…³æ®µè½IDæ•°ç»„"]
    }
  ],
  "metadata": {
    "total_sections": 0,
    "total_length": 0,
    "document_structure": "å±‚æ¬¡åŒ–|æ¨¡å—åŒ–|çº¿æ€§",
    "quality_focus_areas": ["é‡ç‚¹è´¨é‡åˆ†æé¢†åŸŸ"],
    "estimated_complexity": "ä½|ä¸­|é«˜"
  }
}

è¯·ç¡®ä¿ï¼š
- æ®µè½åˆ’åˆ†å…·æœ‰é€»è¾‘å®Œæ•´æ€§ï¼Œä¸è¦éšæ„æˆªæ–­
- åˆ†ç±»æ ‡ç­¾å‡†ç¡®åæ˜ æ®µè½å†…å®¹ç‰¹å¾
- ç›¸å…³æ€§è¯„åˆ†åŸºäºå®é™…å†…å®¹åˆ†æï¼Œè€Œéä¸»è§‚åˆ¤æ–­
- è€ƒè™‘æ–‡æ¡£çš„å®Œæ•´æ€§å’Œä¸Šä¸‹æ–‡å…³ç³»`;

        const provider = apiProvider.value;
        let apiUrl = 'https://api.openai.com/v1/chat/completions';
        let model = 'gpt-4o-mini';

        if (provider === 'deepseek') {
          apiUrl = 'https://api.deepseek.com/v1/chat/completions';
          model = 'deepseek-chat';
        } else if (provider === 'custom') {
          apiUrl = customApiUrl.value;
          model = customModel.value;
        }

        const payload = {
          model: model,
          temperature: 0.1,
          messages: [
            { role: 'system', content: 'ä½ æ˜¯ä¸€ä¸ªæ–‡æ¡£ç»“æ„åˆ†æä¸“å®¶ï¼Œè¯·è¿”å›çº¯JSONæ ¼å¼ã€‚' },
            { role: 'user', content: analysisPrompt },
          ],
        };

        let data = null;
        let contentStr = '';
        
        try {
          const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${apiKey}`,
            },
            body: JSON.stringify(payload),
          });

          if (!response.ok) {
            throw new Error(`æ–‡æ¡£åˆ†æå¤±è´¥: ${response.status}`);
          }

          data = await response.json();
          contentStr = data.choices[0].message.content;

          // æ¸…ç†å¯èƒ½çš„markdownä»£ç å—æ ¼å¼
          if (contentStr.startsWith('```json')) {
            contentStr = contentStr.replace(/^```json\s*/, '').replace(/\s*```$/, '');
          } else if (contentStr.startsWith('```')) {
            // å¤„ç†å…¶ä»–ä»£ç å—æ ¼å¼
            contentStr = contentStr.replace(/^```\s*/, '').replace(/\s*```$/, '');
          }

          const result = JSON.parse(contentStr.trim());

          return {
            ...result,
            usage: data.usage,
            originalText: text
          };
        } catch (error) {
          console.error('AIæ–‡æ¡£åˆ†æå¤±è´¥:', error);
          // å¦‚æœæ˜¯JSONè§£æé”™è¯¯ï¼Œå°è¯•é™çº§å¤„ç†
          if (error instanceof SyntaxError && error.message.includes('JSON') && data && contentStr) {
            console.warn('å°è¯•ä¿®å¤JSONè§£æé”™è¯¯...');
            try {
              let fixedContent = this.repairJsonString(contentStr);
              const result = JSON.parse(fixedContent);
              console.log('JSONè§£æä¿®å¤æˆåŠŸ');

              // éªŒè¯å’Œè¡¥å…¨å¿…éœ€çš„å±æ€§ç»“æ„
              const validatedResult = this.validateAndFixResultStructure(result, text);

              return {
                ...validatedResult,
                usage: data.usage,
                originalText: text
              };
            } catch (fixError) {
              console.error('JSONè§£æä¿®å¤å¤±è´¥:', fixError);
            }
          }
          // é™çº§åˆ°ä¼ ç»Ÿåˆ†å—æ–¹æ³•
          return this.fallbackChunking(text);
        }
      },

      // é™çº§æ–¹æ¡ˆï¼šä¼ ç»Ÿåˆ†å—æ–¹æ³•
      fallbackChunking(text) {
        console.log('fallbackChunking input text length:', text.length);
        console.log('fallbackChunking input text preview:', text.substring(0, 300));

        // å°è¯•å¤šç§åˆ†å‰²æ–¹å¼
        let paragraphs = text.split('\n\n').filter(p => p.trim().length > 50); // é™ä½é˜ˆå€¼
        console.log('After \\n\\n split, paragraphs count:', paragraphs.length);

        // å¦‚æœè¿˜æ˜¯æ²¡æœ‰è¶³å¤Ÿçš„æ®µè½ï¼Œå°è¯•å…¶ä»–åˆ†å‰²æ–¹å¼
        if (paragraphs.length < 2) {
          paragraphs = text.split('\n').filter(p => p.trim().length > 50);
          console.log('After \\n split, paragraphs count:', paragraphs.length);
        }

        // å¦‚æœä»ç„¶æ²¡æœ‰ï¼Œå°è¯•æŒ‰å¥å­åˆ†å‰²
        if (paragraphs.length < 2) {
          paragraphs = text.split(/[.!?]+/).filter(p => p.trim().length > 50);
          console.log('After sentence split, paragraphs count:', paragraphs.length);
        }

        const chunks = [];
        let currentChunk = '';
        let sectionId = 1;

        console.log('Processing paragraphs...');
        for (let i = 0; i < paragraphs.length; i++) {
          const paragraph = paragraphs[i].trim();
          console.log(`Paragraph ${i}: length=${paragraph.length}, preview=${paragraph.substring(0, 100)}`);

          if ((currentChunk + paragraph).length > 1500 && currentChunk.length > 0) {
            chunks.push({
              id: `fallback_${sectionId}`,
              title: `æ–‡æ¡£æ®µè½ ${sectionId}`,
              content: currentChunk.trim(),
              category: 'æ–‡æ¡£å†…å®¹',
              hierarchy_level: 1,
              word_count: currentChunk.trim().split(/\s+/).length,
              tags: ['æ–‡æ¡£å†…å®¹'],
              dependencies: [],
              relevance: {
                'è®¾è®¡ç¼ºé™·æ£€æŸ¥': 5,
                'é€»è¾‘ä¸€è‡´æ€§åˆ†æ': 5,
                'é£é™©è¯„ä¼°': 5
              }
            });
            console.log(`Created chunk ${sectionId} with length ${currentChunk.length}`);
            sectionId++;
            currentChunk = paragraph;
          } else {
            currentChunk += (currentChunk ? '\n\n' : '') + paragraph;
          }
        }

        if (currentChunk.trim()) {
          chunks.push({
            id: `fallback_${sectionId}`,
            title: `æ–‡æ¡£æ®µè½ ${sectionId}`,
            content: currentChunk.trim(),
            category: 'æ–‡æ¡£å†…å®¹',
            hierarchy_level: 1,
            word_count: currentChunk.trim().split(/\s+/).length,
            tags: ['æ–‡æ¡£å†…å®¹'],
            dependencies: [],
            relevance: {
              'è®¾è®¡ç¼ºé™·æ£€æŸ¥': 5,
              'é€»è¾‘ä¸€è‡´æ€§åˆ†æ': 5,
              'é£é™©è¯„ä¼°': 5
            }
          });
          console.log(`Created final chunk ${sectionId} with length ${currentChunk.length}`);
        }

        console.log(`Total chunks created: ${chunks.length}`);

        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ®µè½ï¼Œæ ¹æ®æ–‡æœ¬å†…å®¹åˆ›å»ºåˆç†çš„æ®µè½
        if (chunks.length === 0 && text.trim().length > 0) {
          const trimmedText = text.trim();

          if (trimmedText.length < 200) {
            // æ–‡æœ¬å¾ˆçŸ­ï¼Œæ•´ä¸ªä½œä¸ºä¸€æ®µ
            chunks.push({
              id: 'fallback_1',
              title: 'æ–‡æ¡£å†…å®¹',
              content: trimmedText,
              category: 'æ–‡æ¡£å†…å®¹',
              hierarchy_level: 1,
              word_count: trimmedText.split(/\s+/).length,
              tags: ['çŸ­æ–‡æ¡£'],
              dependencies: [],
              relevance: {
                'è®¾è®¡ç¼ºé™·æ£€æŸ¥': 3,
                'é€»è¾‘ä¸€è‡´æ€§åˆ†æ': 3,
                'é£é™©è¯„ä¼°': 3
              }
            });
          } else {
            // æ–‡æœ¬è¾ƒé•¿ï¼Œåˆ†æˆå‡ æ®µ
            const words = trimmedText.split(/\s+/);
            const chunkSize = Math.ceil(words.length / 3); // åˆ†æˆ3æ®µ

            for (let i = 0; i < 3; i++) {
              const start = i * chunkSize;
              const end = Math.min((i + 1) * chunkSize, words.length);
              const chunkWords = words.slice(start, end);
              const chunkContent = chunkWords.join(' ');

              if (chunkContent.trim()) {
                chunks.push({
                  id: `fallback_${i + 1}`,
                  title: `æ–‡æ¡£éƒ¨åˆ† ${i + 1}`,
                  content: chunkContent,
                  category: 'æ–‡æ¡£å†…å®¹',
                  hierarchy_level: 1,
                  word_count: chunkWords.length,
                  tags: ['æ–‡æ¡£å†…å®¹', `éƒ¨åˆ†${i + 1}`],
                  dependencies: [],
                  relevance: {
                    'è®¾è®¡ç¼ºé™·æ£€æŸ¥': 5,
                    'é€»è¾‘ä¸€è‡´æ€§åˆ†æ': 5,
                    'é£é™©è¯„ä¼°': 5
                  }
                });
              }
            }
          }
        }

        let summary;
        if (chunks.length === 0) {
          if (text.trim().length === 0) {
            summary = 'æ–‡æ¡£å†…å®¹ä¸ºç©ºï¼Œæ— æ³•è¿›è¡Œåˆ†æ';
          } else {
            summary = `æ–‡æ¡£åŒ…å«${text.length}ä¸ªå­—ç¬¦ï¼Œä½†æ— æ³•è¯†åˆ«æ®µè½ç»“æ„ã€‚å¯èƒ½çš„åŸå› ï¼šPDFä¸»è¦æ˜¯å›¾ç‰‡å†…å®¹ã€æ–‡æœ¬æ ¼å¼ç‰¹æ®Šã€æˆ–å†…å®¹è¿‡äºç®€çŸ­`;
          }
        } else {
          const totalWords = chunks.reduce((sum, chunk) => sum + chunk.word_count, 0);
          summary = `æ–‡æ¡£å·²è§£æä¸º${chunks.length}ä¸ªæ®µè½ï¼Œå…±${totalWords}ä¸ªè¯ã€‚é€šè¿‡ä¼ ç»Ÿåˆ†å—æ–¹æ³•è¿›è¡Œç»“æ„åŒ–åˆ†æ`;
        }

        return {
          document_summary: summary,
          document_type: 'æ–‡æ¡£',
          sections: chunks,
          metadata: {
            total_sections: chunks.length,
            total_length: text.length,
            document_structure: 'ä¼ ç»Ÿåˆ†å—',
            quality_focus_areas: ['è®¾è®¡ç¼ºé™·æ£€æŸ¥', 'é€»è¾‘ä¸€è‡´æ€§åˆ†æ', 'é£é™©è¯„ä¼°'],
            estimated_complexity: 'ä¸­'
          },
          usage: null,
          originalText: text
        };
      },

      // ä¿®å¤æŸåçš„JSONå­—ç¬¦ä¸²
      repairJsonString(jsonString) {
        if (!jsonString || typeof jsonString !== 'string') {
          return '{}';
        }

        console.log('å¼€å§‹ä¿®å¤JSONå­—ç¬¦ä¸²ï¼ŒåŸå§‹é•¿åº¦:', jsonString.length);

        // æ­¥éª¤1ï¼šæ¸…ç†markdownä»£ç å—æ ‡è®°
        let cleaned = jsonString;
        cleaned = cleaned.replace(/```json\s*/gi, '').replace(/```\s*$/g, '');
        cleaned = cleaned.replace(/```\w*\s*/gi, '').replace(/```\s*$/g, '');
        cleaned = cleaned.trim();

        // å¦‚æœæ¸…ç†åä¸ºç©ºï¼Œè¿”å›ç©ºå¯¹è±¡
        if (!cleaned) {
          return '{}';
        }

        // æ­¥éª¤2ï¼šå°è¯•æŸ¥æ‰¾JSONèµ·å§‹ä½ç½®
        let startIndex = 0;
        const firstBrace = cleaned.indexOf('{');
        const firstBracket = cleaned.indexOf('[');

        if (firstBrace >= 0 || firstBracket >= 0) {
          if (firstBrace >= 0 && (firstBracket === -1 || firstBrace < firstBracket)) {
            startIndex = firstBrace;
          } else if (firstBracket >= 0) {
            startIndex = firstBracket;
          }
        }

        if (startIndex > 0) {
          cleaned = cleaned.substring(startIndex);
        }

        // æ­¥éª¤3ï¼šåŸºæœ¬ç»“æ„ä¿®å¤
        let result = cleaned;

        // å¤„ç†æœªé—­åˆçš„å­—ç¬¦ä¸²
        result = this.fixUnterminatedStrings(result);

        // å¤„ç†æœªé—­åˆçš„æ•°ç»„å’Œå¯¹è±¡
        result = this.fixUnclosedBrackets(result);

        // å¤„ç†ç¼ºå¤±çš„é€—å·
        result = this.fixMissingCommas(result);

        console.log('JSONä¿®å¤å®Œæˆï¼Œæœ€ç»ˆé•¿åº¦:', result.length);
        return result;
      },

      // ä¿®å¤æœªç»ˆæ­¢çš„å­—ç¬¦ä¸²
      fixUnterminatedStrings(str) {
        const chars = str.split('');
        let inString = false;
        let escapeNext = false;
        let lastQuotePos = -1;

        for (let i = 0; i < chars.length; i++) {
          const char = chars[i];

          if (escapeNext) {
            escapeNext = false;
            continue;
          }

          if (char === '\\') {
            escapeNext = true;
            continue;
          }

          if (char === '"') {
            if (!inString) {
              inString = true;
              lastQuotePos = i;
            } else {
              inString = false;
              lastQuotePos = -1;
            }
          }

          // å¦‚æœé‡åˆ°ç»“æ„å­—ç¬¦ä½†ä»åœ¨å­—ç¬¦ä¸²ä¸­ï¼Œå¯èƒ½æ˜¯æœªè½¬ä¹‰çš„å¼•å·é—®é¢˜
          if (inString && (char === '{' || char === '}' || char === '[' || char === ']' || char === ',')) {
            // åœ¨å½“å‰ä½ç½®ä¹‹å‰æ’å…¥é—­åˆå¼•å·
            chars.splice(i, 0, '"');
            inString = false;
            lastQuotePos = -1;
            i++; // è·³è¿‡åˆšæ’å…¥çš„å¼•å·
          }
        }

        // å¦‚æœæœ€åè¿˜åœ¨å­—ç¬¦ä¸²ä¸­ï¼Œå…³é—­å®ƒ
        if (inString) {
          chars.push('"');
        }

        return chars.join('');
      },

      // ä¿®å¤æœªé—­åˆçš„æ‹¬å·
      fixUnclosedBrackets(str) {
        const chars = str.split('');
        const stack = [];

        for (let i = 0; i < chars.length; i++) {
          const char = chars[i];

          if (char === '{' || char === '[') {
            stack.push({ char, pos: i });
          } else if (char === '}' || char === ']') {
            if (stack.length > 0) {
              const last = stack[stack.length - 1];
              if ((char === '}' && last.char === '{') || (char === ']' && last.char === '[')) {
                stack.pop();
              }
            }
          }
        }

        // ä¸ºæœªé—­åˆçš„æ‹¬å·æ·»åŠ é—­åˆç¬¦å·
        while (stack.length > 0) {
          const item = stack.pop();
          if (item.char === '{') {
            chars.push('}');
          } else if (item.char === '[') {
            chars.push(']');
          }
        }

        return chars.join('');
      },

      // ä¿®å¤ç¼ºå¤±çš„é€—å·
      fixMissingCommas(str) {
        // è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„å®ç°ï¼Œä¸»è¦å¤„ç†å¯¹è±¡å’Œæ•°ç»„ä¸­çš„é€—å·é—®é¢˜
        let result = str;

        // åœ¨å¯¹è±¡å±æ€§ä¹‹é—´æ·»åŠ ç¼ºå¤±çš„é€—å·
        result = result.replace(/}(\s*)"/g, '},$1"');
        result = result.replace(/](\s*)"/g, '],$1"');
        result = result.replace(/}(\s*\{)/g, '},$1');
        result = result.replace(/](\s*\[)/g, '],$1');

        // ç§»é™¤æœ«å°¾å¤šä½™çš„é€—å·
        result = result.replace(/,(\s*[}\]])/g, '$1');

        return result;
      },

      // éªŒè¯å’Œä¿®å¤ç»“æœå¯¹è±¡ç»“æ„
      validateAndFixResultStructure(result, originalText) {
        if (!result || typeof result !== 'object') {
          return this.fallbackChunking(originalText);
        }

        // ç¡®ä¿åŸºæœ¬å±æ€§å­˜åœ¨
        const validated = { ...result };

        // éªŒè¯ document_summary
        if (!validated.document_summary || typeof validated.document_summary !== 'string') {
          validated.document_summary = validated.sections && validated.sections.length > 0
            ? `æˆåŠŸè¯†åˆ«æ–‡æ¡£ç»“æ„ï¼ŒåŒ…å«${validated.sections.length}ä¸ªä¸»è¦æ®µè½`
            : 'æ–‡æ¡£ç»“æ„åˆ†æå®Œæˆï¼Œä½†æœªè¯†åˆ«åˆ°æ˜ç¡®çš„æ®µè½ç»“æ„';
        }

        // éªŒè¯ document_type
        if (!validated.document_type || typeof validated.document_type !== 'string') {
          validated.document_type = 'äº§å“æ–‡æ¡£';
        }

        // éªŒè¯ sections
        if (!Array.isArray(validated.sections)) {
          validated.sections = [];
        }

        // éªŒè¯å’Œä¿®å¤ sections ä¸­çš„æ¯ä¸ªé¡¹ç›®
        validated.sections = validated.sections.map((section, index) => {
          if (!section || typeof section !== 'object') {
            return {
              id: `recovered_${index + 1}`,
              title: `æ¢å¤çš„æ®µè½ ${index + 1}`,
              content: 'å†…å®¹ä¸å¯ç”¨',
              category: 'å…¶ä»–',
              hierarchy_level: 1,
              word_count: 0,
              tags: [],
              dependencies: [],
              relevance: {
                'è®¾è®¡ç¼ºé™·æ£€æŸ¥': 5,
                'é€»è¾‘ä¸€è‡´æ€§åˆ†æ': 5,
                'é£é™©è¯„ä¼°': 5
              }
            };
          }

          return {
            id: section.id || `section_${index + 1}`,
            title: section.title || `æ®µè½ ${index + 1}`,
            content: section.content || '',
            category: section.category || 'å…¶ä»–',
            hierarchy_level: section.hierarchy_level || 1,
            parent_section: section.parent_section || null,
            word_count: section.word_count || (section.content ? section.content.split(/\s+/).length : 0),
            tags: Array.isArray(section.tags) ? section.tags : [],
            dependencies: Array.isArray(section.dependencies) ? section.dependencies : [],
            relevance: section.relevance || {
              'è®¾è®¡ç¼ºé™·æ£€æŸ¥': 5,
              'é€»è¾‘ä¸€è‡´æ€§åˆ†æ': 5,
              'é£é™©è¯„ä¼°': 5
            }
          };
        });

        // éªŒè¯ metadata
        if (!validated.metadata || typeof validated.metadata !== 'object') {
          validated.metadata = {};
        }

        // ç¡®ä¿ metadata æœ‰å¿…éœ€çš„å±æ€§
        validated.metadata.total_sections = validated.metadata.total_sections || validated.sections.length;
        validated.metadata.total_length = validated.metadata.total_length || originalText.length;
        validated.metadata.document_structure = validated.metadata.document_structure || 'æ¨¡å—åŒ–';
        validated.metadata.quality_focus_areas = Array.isArray(validated.metadata.quality_focus_areas)
          ? validated.metadata.quality_focus_areas
          : ['è®¾è®¡ç¼ºé™·æ£€æŸ¥', 'é€»è¾‘ä¸€è‡´æ€§åˆ†æ', 'é£é™©è¯„ä¼°'];
        validated.metadata.estimated_complexity = validated.metadata.estimated_complexity || 'ä¸­';

        return validated;
      },

      // æ ¹æ®åˆ†æç±»å‹é€‰æ‹©æœ€ç›¸å…³çš„æ®µè½ï¼ˆå¢å¼ºç‰ˆï¼‰
      getRelevantSections(processedDoc, analysisType) {
        const { sections } = processedDoc;
        const analysisKey = analysisType.key;

        // 1. é¦–å…ˆæŒ‰ç›¸å…³åº¦è¯„åˆ†æ’åº
        let sortedSections = sections
          .filter(section => section.relevance && section.relevance[analysisKey] > 0)
          .sort((a, b) => (b.relevance[analysisKey] || 0) - (a.relevance[analysisKey] || 0));

        // 2. å¦‚æœç›¸å…³æ®µè½ä¸è¶³ï¼Œè€ƒè™‘ç±»åˆ«åŒ¹é…
        if (sortedSections.length < 3) {
          const categoryBoosts = {
            'è®¾è®¡ç¼ºé™·æ£€æŸ¥': ['åŠŸèƒ½éœ€æ±‚', 'è®¾è®¡è§„èŒƒ', 'ç”¨æˆ·ä½“éªŒ'],
            'é€»è¾‘ä¸€è‡´æ€§åˆ†æ': ['åŠŸèƒ½éœ€æ±‚', 'æ•°æ®æ¨¡å‹', 'ä¸šåŠ¡é€»è¾‘'],
            'é£é™©è¯„ä¼°': ['å®‰å…¨è¦æ±‚', 'æ€§èƒ½æŒ‡æ ‡', 'æŠ€æœ¯æ¶æ„']
          };

          const relevantCategories = categoryBoosts[analysisKey] || [];
          const categorySections = sections
            .filter(section =>
              !sortedSections.includes(section) &&
              relevantCategories.includes(section.category)
            )
            .map(section => ({ ...section, relevance_score: (section.relevance[analysisKey] || 0) + 2 }));

          sortedSections = [...sortedSections, ...categorySections]
            .sort((a, b) => (b.relevance_score || b.relevance[analysisKey] || 0) - (a.relevance_score || a.relevance[analysisKey] || 0));
        }

        // 3. é€‰æ‹©å‰3ä¸ªæœ€ç›¸å…³çš„æ®µè½
        const topSections = sortedSections.slice(0, 3);

        // 4. è€ƒè™‘ä¾èµ–å…³ç³»ï¼Œæ·»åŠ ç›¸å…³è”çš„æ®µè½
        const enhancedSections = [...topSections];
        topSections.forEach(section => {
          if (section.dependencies && Array.isArray(section.dependencies)) {
            section.dependencies.forEach(depId => {
              const depSection = sections.find(s => s.id === depId);
              if (depSection && !enhancedSections.includes(depSection)) {
                enhancedSections.push(depSection);
              }
            });
          }
        });

        // 5. å¦‚æœä»ç„¶ä¸è¶³ï¼Œè¡¥å……ä¸€äº›é€šç”¨æ®µè½
        if (enhancedSections.length < 2) {
          const generalSections = sections
            .filter(section => !enhancedSections.includes(section))
            .sort((a, b) => (b.word_count || 0) - (a.word_count || 0)) // ä¼˜å…ˆé€‰æ‹©å†…å®¹æ›´ä¸°å¯Œçš„æ®µè½
            .slice(0, 2 - enhancedSections.length);
          enhancedSections.push(...generalSections);
        }

        return enhancedSections.slice(0, 4); // æœ€å¤šè¿”å›4ä¸ªæ®µè½
      },

      // ç”Ÿæˆæ®µè½ç»„åˆå†…å®¹
      generateContentForAnalysis(sections, maxLength = 3000) {
        const combinedContent = sections
          .map(section => `[${section.title}]\n${section.content}`)
          .join('\n\n---\n\n');

        // å¦‚æœå†…å®¹è¿‡é•¿ï¼Œè¿›è¡Œæ™ºèƒ½æˆªæ–­
        if (combinedContent.length > maxLength) {
          const truncated = combinedContent.substring(0, maxLength);
          const lastSectionBreak = truncated.lastIndexOf('\n\n---\n\n');
          if (lastSectionBreak > maxLength * 0.7) {
            return truncated.substring(0, lastSectionBreak) + '\n\n[å†…å®¹å·²æˆªæ–­ä»¥æ§åˆ¶tokenæ¶ˆè€—]';
          }
          return truncated + '\n\n[å†…å®¹å·²æˆªæ–­ä»¥æ§åˆ¶tokenæ¶ˆè€—]';
        }

        return combinedContent;
      }
    };

    const analysisTypes = [
      {
        key: 'è®¾è®¡ç¼ºé™·æ£€æŸ¥',
        name: 'è®¾è®¡ç¼ºé™·æ£€æŸ¥',
        prompt: 'è¯·åŸºäºæä¾›çš„æ–‡æ¡£ç‰‡æ®µåˆ†æè®¾è®¡ç¼ºé™·ï¼Œé‡ç‚¹å…³æ³¨UI/UXå’Œäº¤äº’é€»è¾‘é—®é¢˜ã€‚',
        maxContentLength: 3000
      },
      {
        key: 'é€»è¾‘ä¸€è‡´æ€§åˆ†æ',
        name: 'é€»è¾‘ä¸€è‡´æ€§åˆ†æ',
        prompt: 'è¯·åŸºäºæä¾›çš„æ–‡æ¡£ç‰‡æ®µåˆ†æé€»è¾‘ä¸€è‡´æ€§ï¼Œæ£€æŸ¥æ˜¯å¦å­˜åœ¨çŸ›ç›¾æˆ–ä¸ä¸€è‡´çš„åœ°æ–¹ã€‚',
        maxContentLength: 2500
      },
      {
        key: 'é£é™©è¯„ä¼°',
        name: 'é£é™©è¯„ä¼°',
        prompt: 'è¯·åŸºäºæä¾›çš„æ–‡æ¡£ç‰‡æ®µè¯„ä¼°æ½œåœ¨é£é™©å’ŒæŠ€æœ¯å€ºåŠ¡ã€‚',
        maxContentLength: 2000
      }
    ];

    // ä¿å­˜APIè®¾ç½®
    saveKeyBtn.addEventListener('click', () => {
      const key = apiKeyInput.value.trim();
      if (!key) {
        alert('è¯·è¾“å…¥æœ‰æ•ˆçš„ API å¯†é’¥');
        return;
      }

      // ä¿å­˜APIè®¾ç½®
      apiKey = key;
      localStorage.setItem('openai_api_key', key);

      // ä¿å­˜è‡ªå®šä¹‰APIè®¾ç½®
      localStorage.setItem('custom_api_url', customApiUrl.value);
      localStorage.setItem('custom_model', customModel.value);

      saveKeyBtn.textContent = 'å·²ä¿å­˜';
      saveKeyBtn.disabled = true;

      const provider = apiProvider.value;
      const providerName = provider === 'openai' ? 'OpenAI' :
                          provider === 'deepseek' ? 'DeepSeek' : 'è‡ªå®šä¹‰API';
      alert(`${providerName} è®¾ç½®å·²ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨`);

      // æ›´æ–°å¼€å§‹åˆ†ææŒ‰é’®çŠ¶æ€
      startBtn.disabled = !canStartAnalysis();
    });

      // æ£€æŸ¥æ˜¯å¦å¯ä»¥å¼€å§‹åˆ†æ
      function canStartAnalysis() {
        return currentFile && apiKey;
      }

      console.log('Elements initialized, setting up event listeners...');

    fileInput.addEventListener('change', (e) => {
      console.log('File input change event triggered', e.target.files);
      const file = e.target.files?.[0];
      if (!file) {
        console.log('No file selected');
        startBtn.disabled = true;
        fileInfo.textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
        fileInfo.className = 'badge';
        return;
      }

      console.log('File selected:', file.name, 'Type:', file.type, 'Size:', file.size);

      // æ£€æŸ¥æ–‡ä»¶ç±»å‹
      if (file.type !== 'application/pdf') {
        console.log('Invalid file type:', file.type);
        alert('ä»…æ”¯æŒ PDF æ–‡ä»¶');
        startBtn.disabled = true;
        fileInfo.textContent = 'æ–‡ä»¶ç±»å‹é”™è¯¯ï¼ˆä»…æ”¯æŒPDFï¼‰';
        fileInfo.className = 'badge';
        fileInfo.style.background = '#fecaca';
        fileInfo.style.color = '#dc2626';
        return;
      }

      // æ£€æŸ¥æ–‡ä»¶å¤§å°
      if (file.size > 20 * 1024 * 1024) {
        console.log('File too large:', file.size);
        alert('æ–‡ä»¶å¤§å°è¯·æ§åˆ¶åœ¨ 20MB ä»¥å†…');
        startBtn.disabled = true;
        fileInfo.textContent = 'æ–‡ä»¶è¿‡å¤§ï¼ˆæœ€å¤§20MBï¼‰';
        fileInfo.className = 'badge';
        fileInfo.style.background = '#fecaca';
        fileInfo.style.color = '#dc2626';
        return;
      }

      currentFile = file;
      fileInfo.textContent = `${file.name} / ${(file.size / 1024 / 1024).toFixed(2)} MB`;
      fileInfo.className = 'badge';
      fileInfo.style.background = '';
      fileInfo.style.color = '';

      const canStart = canStartAnalysis();
      console.log('File selected:', file.name, 'Can start:', canStart, 'API Key exists:', !!apiKey);
      startBtn.disabled = !canStart;

      // å¦‚æœæœ‰APIå¯†é’¥ä½†æŒ‰é’®ä»è¢«ç¦ç”¨ï¼Œæ˜¾ç¤ºæç¤º
      if (!canStart && apiKey) {
        console.log('API key exists but start button disabled - check canStartAnalysis logic');
      }
    });

    startBtn.addEventListener('click', async () => {
      if (!canStartAnalysis()) return;
      resetUI();

      try {
        logStep(steps[0].label, steps[0].progress);

        // å‡†å¤‡APIè¯·æ±‚æ•°æ®
        const formData = new FormData();
        formData.append('file', currentFile);
        formData.append('provider', apiProvider.value);
        formData.append('apiKey', apiKeyInput.value.trim());

        if (apiProvider.value === 'custom') {
          formData.append('customApiUrl', customApiUrl.value);
          formData.append('customModel', customModel.value);
        }

        // æ˜¾ç¤ºAPIè¯·æ±‚é¢„è§ˆ
        const previewData = {
          endpoint: '/api/analyze',
          method: 'POST',
          provider: apiProvider.value,
          file: `${currentFile.name} (${(currentFile.size / 1024 / 1024).toFixed(2)} MB)`,
          hasApiKey: !!apiKeyInput.value.trim()
        };
        apiRequestPreview.textContent = JSON.stringify(previewData, null, 2);

        logStep('æ­£åœ¨è¿æ¥åç«¯æœåŠ¡...', 15);

        // é€‰æ‹©åˆ†ææ¨¡å¼ï¼šæµå¼æˆ–æ ‡å‡†
        const useStreaming = true; // å¯ä»¥æ ¹æ®ç”¨æˆ·è®¾ç½®æˆ–è‡ªåŠ¨é€‰æ‹©
        const apiUrl = useStreaming
          ? 'http://localhost:3001/api/analyze/stream'
          : 'http://localhost:3001/api/analyze';

        if (useStreaming) {
          // æµå¼åˆ†æ
          await performStreamingAnalysis(formData);
        } else {
          // æ ‡å‡†åˆ†æ
          const response = await fetch(apiUrl, {
            method: 'POST',
            body: formData
          });

          const result = await response.json();
          if (!result.success) {
            throw new Error(result.message || 'åˆ†æå¤±è´¥');
          }

          processAnalysisResult(result.data);
        }

        // æ˜¾ç¤ºæ–‡æ¡£ç»“æ„åˆ†æç»“æœ
        if (analysisData.documentStructure) {
          allResults['æ–‡æ¡£ç»“æ„åˆ†æ'] = analysisData.documentStructure;
          updateDocStats(analysisData.processedDoc);
          renderTabs(allResults);
        }

        // æ˜¾ç¤ºå„åˆ†æé˜¶æ®µçš„ç»“æœ
        const analysisStages = ['è®¾è®¡ç¼ºé™·æ£€æŸ¥', 'é€»è¾‘ä¸€è‡´æ€§åˆ†æ', 'é£é™©è¯„ä¼°'];
        for (let i = 0; i < analysisStages.length; i++) {
          const stageName = analysisStages[i];
          const stepIndex = i + 2; // steps[2]å¼€å§‹æ˜¯ç¬¬ä¸€ä¸ªåˆ†ææ­¥éª¤

          logStep(steps[stepIndex].label, steps[stepIndex].progress);

          if (analysisData[stageName]) {
            allResults[stageName] = analysisData[stageName];
          } else {
            allResults[stageName] = 'åˆ†æé˜¶æ®µæœªå®Œæˆæˆ–å¤±è´¥';
          }

          // æ›´æ–°UIæ˜¾ç¤º
          renderTabs(allResults);
          updateTokenUsage(totalUsage.total_tokens > 0 ? totalUsage : null);
        }

        // ä¿å­˜å®Œæ•´ç»“æœ
        lastResult = {
          success: true,
          analysis_id: crypto.randomUUID(),
          results: allResults,
          metadata: { confidence: 0.8 },
          usage: totalUsage.total_tokens > 0 ? totalUsage : null,
        };

        logStep(steps[5].label, steps[5].progress, true); // æœ€åä¸€æ­¥
        toggleActions(true);
      } catch (err) {
        console.error('Analysis failed:', err);

        let errorMessage = 'åˆ†æå¤±è´¥ï¼š';

        if (err.name === 'AbortError') {
          errorMessage += 'ç½‘ç»œè¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥åé‡è¯•';
        } else if (err.message.includes('Failed to fetch') || err.message.includes('NetworkError')) {
          errorMessage += 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ï¼š\n1. ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸\n2. æ˜¯å¦æœ‰é˜²ç«å¢™é˜»æ­¢è¿æ¥\n3. æ˜¯å¦éœ€è¦é…ç½®ä»£ç†';
        } else if (err.message.includes('CORS')) {
          errorMessage += 'è·¨åŸŸè¯·æ±‚è¢«é˜»æ­¢ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•';
        } else {
          errorMessage += err.message;
        }

        alert(errorMessage);
        toggleActions(false);
      }
    });

    rerunBtn.addEventListener('click', () => startBtn.click());

    exportJsonBtn.addEventListener('click', () => {
      if (!lastResult) return;
      const blob = new Blob([JSON.stringify(lastResult, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `analysis-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
    });

    testConnectionBtn.addEventListener('click', async () => {
      if (!apiKey) {
        alert('è¯·å…ˆè¾“å…¥å¹¶ä¿å­˜APIå¯†é’¥');
        return;
      }

      testConnectionBtn.disabled = true;
      testConnectionBtn.textContent = 'æµ‹è¯•ä¸­...';

      try {
        console.log('Testing API connection via backend...');

        // è°ƒç”¨åç«¯æµ‹è¯•è¿æ¥API
        const response = await fetch('http://localhost:3001/api/test-connection', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            provider: apiProvider.value,
            apiKey: apiKeyInput.value.trim(),
            customApiUrl: customApiUrl.value,
            customModel: customModel.value
          })
        });

        const result = await response.json();

        if (result.success) {
          alert('âœ… è¿æ¥æµ‹è¯•æˆåŠŸï¼ç½‘ç»œå’ŒAPIå¯†é’¥éƒ½æ­£å¸¸ã€‚');
          console.log('Connection test successful');
        } else {
          throw new Error(result.message || 'è¿æ¥æµ‹è¯•å¤±è´¥');
        }

      } catch (err) {
        console.error('Connection test failed:', err);

        let errorMessage = 'âŒ è¿æ¥æµ‹è¯•å¤±è´¥ï¼š\n\n';

        if (err.name === 'AbortError' || err.message.includes('timeout')) {
          errorMessage += 'ç½‘ç»œè¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥';
        } else if (err.message.includes('Failed to fetch') || err.message.includes('NetworkError')) {
          errorMessage += 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œå¯èƒ½æ˜¯ï¼š\nâ€¢ ç½‘ç»œè¿æ¥é—®é¢˜\nâ€¢ åç«¯æœåŠ¡æœªå¯åŠ¨\nâ€¢ é˜²ç«å¢™é˜»æ­¢\nâ€¢ DNSè§£æé—®é¢˜';
        } else if (err.message.includes('401') || err.message.includes('å¯†é’¥')) {
          errorMessage += 'APIå¯†é’¥æ— æ•ˆï¼Œè¯·æ£€æŸ¥å¯†é’¥æ˜¯å¦æ­£ç¡®';
        } else if (err.message.includes('429')) {
          errorMessage += 'è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•';
        } else {
          errorMessage += err.message;
        }

        alert(errorMessage);
      } finally {
        testConnectionBtn.disabled = false;
        testConnectionBtn.textContent = 'æµ‹è¯•è¿æ¥';
      }
    });

    testNetworkBtn.addEventListener('click', async () => {
      testNetworkBtn.disabled = true;
      testNetworkBtn.textContent = 'æµ‹è¯•ä¸­...';
      networkStatus.textContent = 'æµ‹è¯•ä¸­...';
      networkStatus.style.background = '#e0f2fe';
      networkStatus.style.color = '#0369a1';

      const testUrls = [
        'https://httpbin.org/get',
        'https://jsonplaceholder.typicode.com/posts/1',
        'https://api.github.com/zen'
      ];

      let successCount = 0;
      let errorMessages = [];

      for (const url of testUrls) {
        try {
          console.log(`Testing connection to: ${url}`);
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 5000);

          const response = await fetch(url, {
            method: 'GET',
            signal: controller.signal,
          });

          clearTimeout(timeoutId);

          if (response.ok) {
            successCount++;
            console.log(`âœ… ${url} - Success (${response.status})`);
          } else {
            errorMessages.push(`${url}: HTTP ${response.status}`);
            console.log(`âŒ ${url} - Failed (${response.status})`);
          }
        } catch (error) {
          errorMessages.push(`${url}: ${error.message}`);
          console.log(`âŒ ${url} - Error: ${error.message}`);
        }
      }

      // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
      testNetworkBtn.disabled = false;
      testNetworkBtn.textContent = 'æµ‹è¯•ç½‘ç»œè¿æ¥';

      if (successCount === testUrls.length) {
        networkStatus.textContent = 'âœ… ç½‘ç»œæ­£å¸¸';
        networkStatus.style.background = '#dcfce7';
        networkStatus.style.color = '#166534';
        alert('ç½‘ç»œè¿æ¥æµ‹è¯•é€šè¿‡ï¼å¦‚æœOpenAI APIä»ç„¶å¤±è´¥ï¼Œå¯èƒ½æ˜¯åœ°åŒºé™åˆ¶æˆ–APIå¯†é’¥é—®é¢˜ã€‚');
      } else if (successCount > 0) {
        networkStatus.textContent = 'âš ï¸ ç½‘ç»œéƒ¨åˆ†å¯ç”¨';
        networkStatus.style.background = '#fef3c7';
        networkStatus.style.color = '#92400e';
        alert(`ç½‘ç»œéƒ¨åˆ†å¯ç”¨ï¼ˆ${successCount}/${testUrls.length}æˆåŠŸï¼‰ã€‚OpenAI APIå¯èƒ½è¢«åœ°åŒºé™åˆ¶ã€‚`);
      } else {
        networkStatus.textContent = 'âŒ ç½‘ç»œè¿æ¥å¤±è´¥';
        networkStatus.style.background = '#fecaca';
        networkStatus.style.color = '#dc2626';
        alert('ç½‘ç»œè¿æ¥å®Œå…¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè®¾ç½®æˆ–ä½¿ç”¨VPNã€‚');
      }

      if (errorMessages.length > 0) {
        console.log('Network test errors:', errorMessages);
      }
    });

    copySummaryBtn.addEventListener('click', async () => {
      if (!lastResult) return;
      const summary = JSON.stringify(lastResult.results || {}, null, 2);
      await navigator.clipboard.writeText(summary);
      alert('å·²å¤åˆ¶æ‘˜è¦');
    });

    function resetUI() {
      statusList.innerHTML = '';
      progressEl.style.width = '0%';
      resultPanel.textContent = 'åˆ†æä¸­...';
      tabsEl.innerHTML = '';
      lastResult = null;
      toggleActions(false);
      updateDocStats(null); // éšè—æ–‡æ¡£ç»Ÿè®¡
      updateTokenUsage(null); // éšè—tokenä½¿ç”¨æƒ…å†µ
    }

    function toggleActions(enabled) {
      exportJsonBtn.disabled = !enabled;
      copySummaryBtn.disabled = !enabled;
      rerunBtn.disabled = !enabled;
    }

    function updateDocStats(processedDoc) {
      const docStatsEl = document.getElementById('docStats');
      const docLengthEl = document.getElementById('docLength');
      const chunkCountEl = document.getElementById('chunkCount');
      const avgChunkSizeEl = document.getElementById('avgChunkSize');

      if (processedDoc && processedDoc.metadata) {
        const totalLength = processedDoc.metadata.total_length || processedDoc.totalLength || 0;
        const sectionCount = processedDoc.metadata.total_sections || processedDoc.sections?.length || 0;
        const avgSize = totalLength > 0 && sectionCount > 0
          ? Math.round(totalLength / sectionCount)
          : 0;

        // æ˜¾ç¤ºå¢å¼ºçš„æ–‡æ¡£ç»Ÿè®¡ä¿¡æ¯
        const docType = processedDoc.document_type || 'äº§å“æ–‡æ¡£';
        const complexity = processedDoc.metadata.estimated_complexity || 'ä¸­';
        const structure = processedDoc.metadata.document_structure || 'æ¨¡å—åŒ–';

        docLengthEl.textContent = `æ–‡æ¡£ç±»å‹: ${docType} | é•¿åº¦: ${totalLength.toLocaleString()} å­—ç¬¦`;
        chunkCountEl.textContent = `ç»“æ„ç±»å‹: ${structure} | æ®µè½æ•°: ${sectionCount} ä¸ª`;
        avgChunkSizeEl.textContent = `å¤æ‚åº¦: ${complexity} | å¹³å‡æ®µè½å¤§å°: ${avgSize.toLocaleString()} å­—ç¬¦`;
        docStatsEl.style.display = 'block';
      } else {
        docStatsEl.style.display = 'none';
      }
    }

    function updateTokenUsage(usage) {
      const tokenUsageEl = document.getElementById('tokenUsage');
      const promptTokensEl = document.getElementById('promptTokens');
      const completionTokensEl = document.getElementById('completionTokens');
      const totalTokensEl = document.getElementById('totalTokens');

      if (usage && usage.total_tokens > 0) {
        promptTokensEl.textContent = `è¾“å…¥: ${usage.prompt_tokens || 0}`;
        completionTokensEl.textContent = `è¾“å‡º: ${usage.completion_tokens || 0}`;
        totalTokensEl.textContent = `æ€»è®¡: ${usage.total_tokens || 0} (å·²ä¼˜åŒ–åˆ†å—å¤„ç†)`;
        tokenUsageEl.style.display = 'block';
      } else {
        tokenUsageEl.style.display = 'none';
      }
    }

    function logStep(text, pct, done = false) {
      const li = document.createElement('li');
      li.textContent = `[${pct}%] ${done ? 'âœ…' : 'â–¶'} ${text}`;
      statusList.appendChild(li);
      progressEl.style.width = `${pct}%`;
    }

    async function parsePdf(file) {
      if (typeof pdfjsLib === 'undefined') {
        throw new Error('PDF.js åº“æœªæ­£ç¡®åŠ è½½ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
      }

      console.log('å¼€å§‹è§£æPDFæ–‡ä»¶ï¼Œå¤§å°:', file.size, 'bytes');

      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      console.log('PDFæ–‡æ¡£é¡µæ•°:', pdf.numPages);

      let fullText = '';
      let totalItems = 0;

      for (let i = 1; i <= pdf.numPages; i++) {
        console.log(`è§£æç¬¬${i}é¡µ...`);
        const page = await pdf.getPage(i);
        const content = await page.getTextContent();

        console.log(`ç¬¬${i}é¡µæ–‡æœ¬é¡¹æ•°é‡:`, content.items.length);
        totalItems += content.items.length;

        // å°è¯•ä¿ç•™åŸå§‹çš„æ–‡æœ¬ç»“æ„
        let pageText = '';
        let lastY = null;
        let lineText = '';

        for (const item of content.items) {
          const text = item.str.trim();
          if (!text) continue;

          // å¦‚æœYåæ ‡å˜åŒ–å¾ˆå¤§ï¼Œå¯èƒ½æ˜¯æ–°è¡Œ
          if (lastY !== null && Math.abs(item.transform[5] - lastY) > 5) {
            if (lineText) {
              pageText += lineText + '\n';
              lineText = '';
            }
          }

          lineText += (lineText ? ' ' : '') + text;
          lastY = item.transform[5];
        }

        if (lineText) {
          pageText += lineText + '\n';
        }

        fullText += `\n[Page ${i}]\n${pageText}\n`;
      }

      console.log('PDFè§£æå®Œæˆï¼Œæ€»æ–‡æœ¬é•¿åº¦:', fullText.length, 'æ€»æ–‡æœ¬é¡¹:', totalItems);
      console.log('è§£æç»“æœé¢„è§ˆ:', fullText.substring(0, 300));

      // å¦‚æœæ–‡æœ¬å¤ªçŸ­ï¼Œå¯èƒ½æœ‰é—®é¢˜
      if (fullText.trim().length < 100) {
        console.warn('è­¦å‘Šï¼šè§£æå‡ºçš„æ–‡æœ¬å†…å®¹å¾ˆå°‘ï¼Œå¯èƒ½PDFä¸»è¦æ˜¯å›¾ç‰‡æˆ–æ‰«æä»¶');
      }

      return fullText;
    }

    // æµå¼åˆ†æå‡½æ•°
    async function performStreamingAnalysis(formData) {
      console.log('å¼€å§‹æ‰§è¡ŒperformStreamingAnalysis');
      return new Promise(async (resolve, reject) => {
        try {
          // æ˜¾ç¤ºæµå¼åˆ†æçŠ¶æ€
          logStep('æ­£åœ¨å¯åŠ¨æµå¼åˆ†æ...', 5);
          console.log('æ˜¾ç¤ºæµå¼çŠ¶æ€');

          // åˆ›å»ºæµå¼æ˜¾ç¤ºå®¹å™¨
          createStreamingDisplay();
          console.log('åˆ›å»ºæµå¼æ˜¾ç¤ºå®¹å™¨');

          // å¯åŠ¨æµå¼åˆ†æè¯·æ±‚
          console.log('å¼€å§‹å‘é€æµå¼åˆ†æè¯·æ±‚åˆ°: http://localhost:3001/api/analyze/stream');
          console.log('FormDataå†…å®¹:', Array.from(formData.entries()));

          const analysisPromise = fetch('http://localhost:3001/api/analyze/stream', {
            method: 'POST',
            body: formData,
            signal: AbortSignal.timeout(30000) // 30ç§’è¶…æ—¶
          }).then(async (response) => {
            console.log('æ”¶åˆ°å“åº”:', {
              ok: response.ok,
              status: response.status,
              statusText: response.statusText,
              headers: Object.fromEntries(response.headers.entries())
            });
            if (!response.ok) {
              let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
              try {
                const errorData = await response.text();
                console.log('é”™è¯¯å“åº”å†…å®¹:', errorData);
                errorMessage += ` - ${errorData}`;
              } catch (e) {
                console.log('æ— æ³•è¯»å–é”™è¯¯å“åº”å†…å®¹');
              }
              throw new Error(errorMessage);
            }

            // æ£€æŸ¥æ˜¯å¦æ”¯æŒReadableStream
            if (!response.body || typeof response.body.getReader !== 'function') {
              console.warn('æµè§ˆå™¨ä¸æ”¯æŒReadableStreamï¼Œé™çº§å¤„ç†...');
              // é™çº§ä¸ºéæµå¼å¤„ç†
              const result = await response.json();
              if (!result.success) {
                throw new Error(result.message || 'åˆ†æå¤±è´¥');
              }

              // æ¨¡æ‹Ÿæµå¼è¿›åº¦
              const stages = ['structure', 'design', 'logic', 'risk'];
              for (let i = 0; i < stages.length; i++) {
                const stage = stages[i];
                const progress = getStageProgress(stage);
                logStep(`${getStageDisplayName(stage)}å®Œæˆ`, progress);
                updateStreamingContent(stage, `æ­£åœ¨è¿›è¡Œ${getStageDisplayName(stage)}...`);
                await new Promise(resolve => setTimeout(resolve, 1000)); // æ¨¡æ‹Ÿå»¶è¿Ÿ
              }

              logStep('âœ… åˆ†æå®Œæˆï¼', 100, true);
              updateStreamingContent('complete', 'ğŸ‰ åˆ†æå®Œæˆï¼Œæ˜¾ç¤ºå®Œæ•´ç»“æœ');

              setTimeout(() => {
                processAnalysisResult(result.data);
                removeStreamingDisplay();
              }, 1500);

              return {
                success: true,
                data: result.data,
                usage: result.usage
              };
            }

            return new Promise((resolve, reject) => {
              let buffer = '';
              let allResults = {};
              let totalUsage = { total_tokens: 0 };

              console.log('å“åº”å¯¹è±¡:', {
                ok: response.ok,
                status: response.status,
                headers: Object.fromEntries(response.headers.entries()),
                bodyUsed: response.bodyUsed,
                hasBody: !!response.body
              });

              const reader = response.body.getReader();
              const decoder = new TextDecoder();
              console.log('åˆ›å»ºäº†ReadableStream reader');

              function processStream() {
                reader.read().then(({ done, value }) => {
                  if (done) {
                    console.log('æµå¼å“åº”å®Œæˆ');
                    resolve({
                      success: true,
                      data: allResults,
                      usage: totalUsage
                    });
                    return;
                  }

                  const chunk = decoder.decode(value, { stream: true });
                  console.log('æ”¶åˆ°æµå¼æ•°æ®å—:', chunk.length, 'å­—ç¬¦');
                  buffer += chunk;
                  const lines = buffer.split('\n');

                  // ä¿ç•™ä¸å®Œæ•´çš„è¡Œ
                  buffer = lines.pop();
                  console.log('ç¼“å†²åŒºå‰©ä½™:', buffer.length, 'å­—ç¬¦');

                  for (const line of lines) {
                    console.log('å¤„ç†è¡Œ:', line.substring(0, 100));
                    if (line.startsWith('data: ')) {
                      const dataStr = line.slice(6).trim();
                      if (dataStr === '[DONE]') {
                        resolve({
                          success: true,
                          data: allResults,
                          usage: totalUsage
                        });
                        return;
                      }

                      try {
                        console.log('è§£ææµå¼æ•°æ®:', dataStr.substring(0, 200));
                        const data = JSON.parse(dataStr);
                        console.log('æˆåŠŸè§£ææ•°æ®:', { stage: data.stage, hasChunk: !!data.chunk, hasCompleted: !!data.completed });

                        if (data.stage === 'complete') {
                          // åˆ†æå®Œæˆ
                          allResults = data.results;

                          // æ˜¾ç¤ºæœ€ç»ˆç»“æœ
                          logStep('âœ… åˆ†æå®Œæˆï¼', 100, true);
                          updateStreamingContent('complete', 'ğŸ‰ åˆ†æå®Œæˆï¼Œæ˜¾ç¤ºå®Œæ•´ç»“æœ');

                          // å»¶è¿Ÿä¸€ä¸‹æ˜¾ç¤ºå®Œæ•´ç»“æœï¼Œè®©ç”¨æˆ·çœ‹åˆ°å®ŒæˆçŠ¶æ€
                          setTimeout(() => {
                            processAnalysisResult(allResults);
                            removeStreamingDisplay();
                            resolve({
                              success: true,
                              data: allResults,
                              usage: totalUsage
                            });
                          }, 1500);

                        } else if (data.completed) {
                          // é˜¶æ®µå®Œæˆ
                          const stageName = data.stage.replace('_complete', '');
                          const stageDisplayName = getStageDisplayName(stageName);
                          const progress = getStageProgress(stageName);

                          if (stageName === 'structure') {
                            // æ–‡æ¡£ç»“æ„åˆ†æå®Œæˆï¼Œæ˜¾ç¤ºæ‘˜è¦ä¿¡æ¯
                            const sectionCount = data.sectionCount || 0;
                            updateStreamingContent(stageName, `æ–‡æ¡£ç»“æ„åˆ†æå®Œæˆï¼Œå‘ç° ${sectionCount} ä¸ªæ®µè½`);
                          }

                          logStep(`${stageDisplayName}å®Œæˆ`, progress);
                        } else if (data.chunk) {
                          // å®æ—¶å†…å®¹æ›´æ–° - æ£€æŸ¥å†…å®¹æ˜¯å¦é€‚åˆæ˜¾ç¤º
                          let displayContent = data.chunk;

                          if (data.stage === 'structure') {
                            // ç»“æ„åˆ†æé˜¶æ®µæ˜¾ç¤ºå‹å¥½æ–‡æœ¬
                            displayContent = 'æ­£åœ¨åˆ†ææ–‡æ¡£ç»“æ„ï¼Œè¯†åˆ«ç« èŠ‚å’Œæ®µè½å±‚æ¬¡...';
                          } else if (data.chunk.trim().startsWith('{') || data.chunk.trim().startsWith('[')) {
                            // å¦‚æœæ˜¯JSONæ ¼å¼ï¼Œæ˜¾ç¤ºå‹å¥½æ–‡æœ¬
                            const stageMessages = {
                              'design': 'æ­£åœ¨æ£€æŸ¥UI/UXè®¾è®¡è§„èŒƒå’Œäº¤äº’é€»è¾‘...',
                              'logic': 'æ­£åœ¨åˆ†æä¸šåŠ¡é€»è¾‘è¿è´¯æ€§å’Œæ•°æ®æµä¸€è‡´æ€§...',
                              'risk': 'æ­£åœ¨è¯„ä¼°æŠ€æœ¯é£é™©å’Œå®‰å…¨éšæ‚£...'
                            };
                            displayContent = stageMessages[data.stage] || `æ­£åœ¨è¿›è¡Œ${getStageDisplayName(data.stage)}...`;
                          }

                          updateStreamingContent(data.stage, displayContent);
                        }
                      } catch (error) {
                        console.error('è§£ææµå¼æ•°æ®å¤±è´¥:', error, 'åŸå§‹æ•°æ®:', dataStr);
                      }
                    }
                  }

                  processStream();
                }).catch(reject);
              }

              processStream();
            });
          });

        } catch (error) {
          console.error('æµå¼åˆ†æå¤±è´¥:', error);
          console.error('é”™è¯¯ç±»å‹:', error.constructor.name);
          console.error('é”™è¯¯è¯¦æƒ…:', error);

          // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯è€Œä¸æ˜¯ç§»é™¤æ˜¾ç¤º
          let errorMsg = error.message;
          if (error.name === 'AbortError') {
            errorMsg = 'è¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–åç«¯æœåŠ¡çŠ¶æ€';
          } else if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
            errorMsg = 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·ç¡®ä¿åç«¯æœåŠ¡æ­£åœ¨è¿è¡Œ (localhost:3001)';
          }

          updateStreamingContent('error', `åˆ†æå¤±è´¥ï¼š${errorMsg}`);
          setTimeout(() => {
            removeStreamingDisplay();
            reject(error);
          }, 5000); // å»¶é•¿æ˜¾ç¤ºæ—¶é—´è®©ç”¨æˆ·çœ‹åˆ°é”™è¯¯ä¿¡æ¯
        }
      });
    }

    // åˆ›å»ºæµå¼æ˜¾ç¤ºå®¹å™¨
    function createStreamingDisplay() {
      // åˆ›å»ºæµå¼æ˜¾ç¤ºåŒºåŸŸ
      const streamingContainer = document.createElement('div');
      streamingContainer.id = 'streaming-display';
      streamingContainer.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 30px;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        z-index: 10000;
        max-width: 500px;
        text-align: center;
        font-family: 'Arial', sans-serif;
      `;

      streamingContainer.innerHTML = `
        <div style="margin-bottom: 20px;">
          <div style="font-size: 24px; margin-bottom: 10px;">ğŸ¤– AI æ­£åœ¨åˆ†æä¸­...</div>
          <div id="streaming-stage" style="font-size: 18px; color: #4ade80; margin-bottom: 15px;">å‡†å¤‡å¼€å§‹</div>
          <div id="streaming-content" style="font-size: 14px; line-height: 1.6; color: #e5e7eb; min-height: 60px;">
            åˆå§‹åŒ–åˆ†æç¯å¢ƒ...
          </div>
        </div>
        <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
          <div id="streaming-spinner" style="width: 20px; height: 20px; border: 2px solid #374151; border-top: 2px solid #4ade80; border-radius: 50%; animation: spin 1s linear infinite;"></div>
          <div style="font-size: 12px; color: #9ca3af;">è¯·è€å¿ƒç­‰å¾…</div>
        </div>
        <style>
          @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
          @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
          }
          @keyframes fadeOut {
            from { opacity: 1; transform: scale(1); }
            to { opacity: 0; transform: scale(0.9); }
          }
        </style>
      `;

      document.body.appendChild(streamingContainer);
    }

    // æ›´æ–°æµå¼å†…å®¹æ˜¾ç¤º
    function updateStreamingContent(stage, content) {
      const streamingContainer = document.getElementById('streaming-display');
      if (!streamingContainer) return;

      const stageElement = document.getElementById('streaming-stage');
      const contentElement = document.getElementById('streaming-content');

      if (stageElement && contentElement) {
        // æ›´æ–°é˜¶æ®µæ˜¾ç¤º
        const stageNames = {
          'structure': 'ğŸ“„ æ–‡æ¡£ç»“æ„åˆ†æ',
          'design': 'ğŸ¨ è®¾è®¡ç¼ºé™·æ£€æŸ¥',
          'logic': 'ğŸ§  é€»è¾‘ä¸€è‡´æ€§åˆ†æ',
          'risk': 'âš ï¸ é£é™©è¯„ä¼°',
          'complete': 'âœ… åˆ†æå®Œæˆ'
        };

        stageElement.textContent = stageNames[stage] || stage;
        contentElement.textContent = content;

        // æ·»åŠ ä¸€äº›åŠ¨ç”»æ•ˆæœ
        contentElement.style.animation = 'fadeIn 0.5s ease-in';
        setTimeout(() => {
          contentElement.style.animation = '';
        }, 500);
      }

      console.log(`[${stage}] ${content}`);
    }

    // ç§»é™¤æµå¼æ˜¾ç¤ºå®¹å™¨
    function removeStreamingDisplay() {
      const streamingContainer = document.getElementById('streaming-display');
      if (streamingContainer) {
        streamingContainer.style.animation = 'fadeOut 0.5s ease-out';
        setTimeout(() => {
          if (streamingContainer.parentNode) {
            streamingContainer.parentNode.removeChild(streamingContainer);
          }
        }, 500);
      }
    }

    // å¤„ç†åˆ†æç»“æœ
    function processAnalysisResult(analysisData) {
      // å¤„ç†åˆ†æç»“æœ
      const allResults = {};
      const totalUsage = analysisData.usage || { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 };

      // æ˜¾ç¤ºæ–‡æ¡£ç»“æ„åˆ†æç»“æœ
      if (analysisData.documentStructure) {
        allResults['æ–‡æ¡£ç»“æ„åˆ†æ'] = analysisData.documentStructure;
        updateDocStats(analysisData.processedDoc);
        renderTabs(allResults);
      }

      // æ˜¾ç¤ºå„åˆ†æé˜¶æ®µçš„ç»“æœ
      const analysisStages = ['è®¾è®¡ç¼ºé™·æ£€æŸ¥', 'é€»è¾‘ä¸€è‡´æ€§åˆ†æ', 'é£é™©è¯„ä¼°'];
      for (let i = 0; i < analysisStages.length; i++) {
        const stageName = analysisStages[i];

        if (analysisData[stageName]) {
          allResults[stageName] = analysisData[stageName];
        } else {
          allResults[stageName] = 'åˆ†æé˜¶æ®µæœªå®Œæˆæˆ–å¤±è´¥';
        }

        renderTabs(allResults);
        updateTokenUsage(totalUsage.total_tokens > 0 ? totalUsage : null);
      }

      // ä¿å­˜å®Œæ•´ç»“æœ
      lastResult = {
        success: true,
        analysis_id: crypto.randomUUID(),
        results: allResults,
        metadata: { confidence: 0.8 },
        usage: totalUsage.total_tokens > 0 ? totalUsage : null,
      };

      logStep(steps[5].label, steps[5].progress, true);
      toggleActions(true);
    }

    // è·å–é˜¶æ®µæ˜¾ç¤ºåç§°
    function getStageDisplayName(stage) {
      const names = {
        'structure': 'AIåˆ†ææ–‡æ¡£ç»“æ„',
        'design': 'AIåˆ†æè®¾è®¡ç¼ºé™·',
        'logic': 'AIåˆ†æé€»è¾‘ä¸€è‡´æ€§',
        'risk': 'AIåˆ†æé£é™©è¯„ä¼°'
      };
      return names[stage] || stage;
    }

    // è·å–é˜¶æ®µè¿›åº¦
    function getStageProgress(stage) {
      const progresses = {
        'structure': 15,
        'design': 40,
        'logic': 70,
        'risk': 95
      };
      return progresses[stage] || 50;
    }

    function buildApiRequest(processedDoc, analysisType) {
      // è·å–ä¸å½“å‰åˆ†æç±»å‹æœ€ç›¸å…³çš„æ®µè½
      const relevantSections = documentProcessor.getRelevantSections(processedDoc, analysisType);
      const contentToAnalyze = documentProcessor.generateContentForAnalysis(relevantSections, analysisType.maxContentLength);

      const prompt = `è¯·åŸºäºä»¥ä¸‹æ–‡æ¡£ç‰‡æ®µè¿›è¡Œ${analysisType.name}ï¼Œå¹¶è¿”å›çº¯JSONæ ¼å¼ï¼ˆä¸è¦åŒ…å«markdownä»£ç å—æ ‡è®°ï¼‰ï¼š

åˆ†æè¦æ±‚: ${analysisType.prompt}
å“åº”æ ¼å¼: çº¯JSONï¼Œä¸è¦ä½¿ç”¨\`\`\`jsonä»£ç å—æ ¼å¼

æ–‡æ¡£ç‰‡æ®µ (å·²ç”±AIæ™ºèƒ½åˆ†æå¹¶é€‰æ‹©æœ€ç›¸å…³çš„å†…å®¹):
${contentToAnalyze}

è¯·è¿”å›ä»¥ä¸‹ç»“æ„çš„çº¯JSONï¼ˆç›´æ¥ä»¥{å¼€å¤´ï¼Œä¸è¦ä»»ä½•markdownæ ¼å¼ï¼‰ï¼š
{
  "result": "è¯¦ç»†çš„${analysisType.name}åˆ†æå†…å®¹...",
  "confidence": 0.85
}`;

      const provider = apiProvider.value;
      let model = 'gpt-4o-mini'; // é»˜è®¤OpenAI

      if (provider === 'deepseek') {
        model = 'deepseek-chat';
      } else if (provider === 'custom') {
        model = customModel.value;
      }

      return {
        model: model,
        temperature: 0.2,
        messages: [
          { role: 'system', content: 'ä½ æ˜¯äº§å“æ–‡æ¡£å®¡æŸ¥åŠ©æ‰‹ï¼Œè¯·åªè¾“å‡ºçº¯JSONæ ¼å¼ï¼Œä¸è¦åŒ…å«ä»»ä½•markdownä»£ç å—ã€‚' },
          { role: 'user', content: prompt },
        ],
      };
    }


    let currentResults = {};

    function renderTabs(results = {}) {
      currentResults = results; // ä¿å­˜å½“å‰çš„ç»“æœæ•°æ®
      const completedKeys = Object.keys(results);
      const allKeys = ['æ–‡æ¡£ç»“æ„åˆ†æ', ...analysisTypes.map(t => t.key)];

      tabsEl.innerHTML = '';

      allKeys.forEach((k, idx) => {
        const tab = document.createElement('div');
        const isCompleted = completedKeys.includes(k);
        const isActive = idx === 0 || (!completedKeys.includes(allKeys[0]) && completedKeys.includes(k));

        tab.className = 'tab' + (isActive ? ' active' : '');
        tab.textContent = isCompleted ? k : `${k} (åˆ†æä¸­...)`;
        tab.style.opacity = isCompleted ? '1' : '0.6';
        tab.onclick = () => setActiveTab(k);
        tabsEl.appendChild(tab);
      });

      // å¦‚æœæœ‰ä»»ä½•ç»“æœï¼Œæ˜¾ç¤ºç¬¬ä¸€ä¸ªå®Œæˆçš„æ ‡ç­¾
      const firstCompletedKey = allKeys.find(k => completedKeys.includes(k));
      if (firstCompletedKey) {
        setActiveTab(firstCompletedKey);
      } else {
        resultPanel.innerHTML = '<div class="result-content"><p>AIæ­£åœ¨åˆ†ææ–‡æ¡£ç»“æ„ï¼Œè¯·ç¨å€™...</p></div>';
      }
    }

    function setActiveTab(key) {
      // å¤„ç†å¸¦"(åˆ†æä¸­...)"åç¼€çš„æ ‡ç­¾å
      const cleanKey = key.replace(' (åˆ†æä¸­...)', '');
      [...tabsEl.children].forEach(t => {
        const tabKey = t.textContent.replace(' (åˆ†æä¸­...)', '');
        t.classList.toggle('active', tabKey === cleanKey);
      });

      const data = currentResults?.[cleanKey];

      if (data) {
        resultPanel.innerHTML = `
          <div class="result-content">
            ${renderAnalysisContent(cleanKey, data)}
          </div>
        `;
      } else {
        // æ˜¾ç¤ºç­‰å¾…ä¿¡æ¯
        const waitingMessages = {
          'æ–‡æ¡£ç»“æ„åˆ†æ': 'AIæ­£åœ¨åˆ†ææ–‡æ¡£ç»“æ„å’Œåˆ†å—ï¼Œè¯·ç¨å€™...',
          'è®¾è®¡ç¼ºé™·æ£€æŸ¥': 'æ­£åœ¨æ£€æŸ¥UI/UXè®¾è®¡å’Œäº¤äº’é€»è¾‘ç¼ºé™·...',
          'é€»è¾‘ä¸€è‡´æ€§åˆ†æ': 'æ­£åœ¨åˆ†ææ–‡æ¡£é€»è¾‘ä¸€è‡´æ€§å’Œæ½œåœ¨çŸ›ç›¾...',
          'é£é™©è¯„ä¼°': 'æ­£åœ¨è¯„ä¼°æ½œåœ¨é£é™©å’ŒæŠ€æœ¯å€ºåŠ¡...'
        };

        resultPanel.innerHTML = `
          <div class="result-content">
            <div style="text-align: center; padding: 40px; color: #6b7280;">
              <div style="font-size: 48px; margin-bottom: 16px;">â³</div>
              <p style="font-size: 16px; margin: 0;">${waitingMessages[cleanKey] || 'åˆ†æè¿›è¡Œä¸­...'}</p>
            </div>
          </div>
        `;
      }
    }

    function getTabIcon(key) {
      const icons = {
        'è®¾è®¡ç¼ºé™·æ£€æŸ¥': 'ğŸ”',
        'é€»è¾‘ä¸€è‡´æ€§åˆ†æ': 'ğŸ§ ',
        'é£é™©è¯„ä¼°': 'âš ï¸'
      };
      return icons[key] || 'ğŸ“‹';
    }

    function getConfidenceClass(confidence) {
      if (confidence >= 0.8) return 'confidence-high';
      if (confidence >= 0.6) return 'confidence-medium';
      return 'confidence-low';
    }

    function renderAnalysisContent(key, data) {
      if (!data) return '<p>æš‚æ— åˆ†æå†…å®¹</p>';

      // å¦‚æœdataæ˜¯å­—ç¬¦ä¸²ï¼Œç›´æ¥æ˜¾ç¤º
      if (typeof data === 'string') {
        return `<div class="result-section">
          <div class="section-content">${formatText(data)}</div>
        </div>`;
      }

      // å¦‚æœdataæ˜¯å¯¹è±¡ï¼Œå°è¯•ç»“æ„åŒ–æ˜¾ç¤º
      if (typeof data === 'object') {
        return renderStructuredContent(key, data);
      }

      return `<div class="result-section">
        <div class="section-content">${data}</div>
      </div>`;
    }

    function renderStructuredContent(key, data) {
      let html = '';

      if (key === 'è®¾è®¡ç¼ºé™·æ£€æŸ¥') {
        html = renderDefectAnalysis(data);
      } else if (key === 'é€»è¾‘ä¸€è‡´æ€§åˆ†æ') {
        html = renderConsistencyAnalysis(data);
      } else if (key === 'é£é™©è¯„ä¼°') {
        html = renderRiskAssessment(data);
      } else {
        // é»˜è®¤ç»“æ„åŒ–æ˜¾ç¤º
        html = renderDefaultStructure(data);
      }

      return html;
    }

    function renderDefectAnalysis(data) {
      let html = '';
      if (data.å‘ç°çš„é—®é¢˜) {
        html += `<div class="result-section">
          <h4 class="section-title">ğŸ” å‘ç°çš„é—®é¢˜</h4>
          <div class="section-content">${formatText(data.å‘ç°çš„é—®é¢˜)}</div>
        </div>`;
      }
      if (data.æ”¹è¿›å»ºè®®) {
        html += `<div class="result-section">
          <h4 class="section-title">ğŸ’¡ æ”¹è¿›å»ºè®®</h4>
          <div class="section-content">${formatText(data.æ”¹è¿›å»ºè®®)}</div>
        </div>`;
      }
      return html || renderDefaultStructure(data);
    }

    function renderConsistencyAnalysis(data) {
      let html = '';
      if (data.ä¸€è‡´æ€§æ£€æŸ¥) {
        html += `<div class="result-section">
          <h4 class="section-title">ğŸ§  ä¸€è‡´æ€§æ£€æŸ¥ç»“æœ</h4>
          <div class="section-content">${formatText(data.ä¸€è‡´æ€§æ£€æŸ¥)}</div>
        </div>`;
      }
      if (data.æ½œåœ¨å†²çª) {
        html += `<div class="result-section">
          <h4 class="section-title">âš ï¸ æ½œåœ¨å†²çª</h4>
          <div class="section-content warning">${formatText(data.æ½œåœ¨å†²çª)}</div>
        </div>`;
      }
      return html || renderDefaultStructure(data);
    }

    function renderRiskAssessment(data) {
      let html = '';
      if (data.é£é™©ç­‰çº§) {
        const riskLevel = data.é£é™©ç­‰çº§.toLowerCase();
        const riskClass = riskLevel.includes('é«˜') ? 'warning' : riskLevel.includes('ä¸­') ? 'highlight' : 'success';
        html += `<div class="result-section">
          <h4 class="section-title">âš ï¸ é£é™©ç­‰çº§</h4>
          <div class="section-content ${riskClass}">${data.é£é™©ç­‰çº§}</div>
        </div>`;
      }
      if (data.é£é™©æè¿°) {
        html += `<div class="result-section">
          <h4 class="section-title">ğŸ“ é£é™©æè¿°</h4>
          <div class="section-content">${formatText(data.é£é™©æè¿°)}</div>
        </div>`;
      }
      if (data.ç¼“è§£æªæ–½) {
        html += `<div class="result-section">
          <h4 class="section-title">ğŸ›¡ï¸ ç¼“è§£æªæ–½</h4>
          <div class="section-content">${formatText(data.ç¼“è§£æªæ–½)}</div>
        </div>`;
      }
      return html || renderDefaultStructure(data);
    }

    function renderDefaultStructure(data) {
      let html = '';
      for (const [label, content] of Object.entries(data)) {
        html += `<div class="analysis-item">
          <div class="analysis-label">${label}:</div>
          <div class="analysis-text">${formatText(content)}</div>
        </div>`;
      }
      return html;
    }

    function formatText(text) {
      if (typeof text !== 'string') return JSON.stringify(text, null, 2);

      // å¤„ç†ç¼–å·åˆ—è¡¨æ ¼å¼ï¼ˆå¦‚ï¼š1. å†…å®¹\n2. å†…å®¹ï¼‰
      const lines = text.split('\n');
      const formattedLines = lines.map(line => {
        // æ£€æŸ¥æ˜¯å¦æ˜¯ç¼–å·é¡¹ç›®ï¼ˆä»¥æ•°å­—+ç‚¹+ç©ºæ ¼å¼€å¤´ï¼‰
        if (/^\d+\.\s/.test(line)) {
          return `<div class="analysis-item">${line}</div>`;
        }
        // æ£€æŸ¥æ˜¯å¦æ˜¯æ— ç¼–å·çš„æ®µè½
        else if (line.trim()) {
          return `<p>${line.trim()}</p>`;
        }
        return '';
      }).filter(line => line);

      return formattedLines.join('');
    }

    console.log('Initialization complete');
    } // å…³é—­initializeAppå‡½æ•°
  </script>
</body>
</html>


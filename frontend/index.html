<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI äº§å“æ–‡æ¡£å®¡æŸ¥</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" />
  <style>
    body { font-family: Arial, sans-serif; background: #f7f7f9; color: #1f2937; margin: 0; padding: 0; }
    header { background: #0f172a; color: #fff; padding: 16px 24px; }
    main { max-width: 1080px; margin: 24px auto; padding: 0 16px 48px; }
    .card { background: #fff; border-radius: 10px; box-shadow: 0 10px 30px rgba(15, 23, 42, 0.08); padding: 20px; margin-bottom: 18px; }
    .flex { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .btn { background: #2563eb; color: #fff; border: none; border-radius: 8px; padding: 10px 16px; cursor: pointer; font-weight: 600; }
    .btn:disabled { background: #94a3b8; cursor: not-allowed; }
    .progress-bar { width: 100%; background: #e5e7eb; border-radius: 8px; overflow: hidden; height: 10px; margin: 8px 0; }
    .progress { height: 100%; background: linear-gradient(90deg, #2563eb, #22d3ee); width: 0%; transition: width 0.25s ease; }
    .status-list { margin: 8px 0; padding-left: 18px; color: #475569; }
    .tabs { display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap; border-bottom: 1px solid #e2e8f0; padding-bottom: 8px; }
    .tab { padding: 10px 16px; border-radius: 8px; background: #f3f4f6; color: #6b7280; cursor: pointer; font-weight: 600; transition: all 0.2s ease; border: 1px solid transparent; }
    .tab:hover { background: #e5e7eb; color: #374151; }
    .tab.active { background: #2563eb; color: #fff; border-color: #1d4ed8; box-shadow: 0 2px 4px rgba(37, 99, 235, 0.1); }
    pre { background: #0f172a; color: #e2e8f0; padding: 12px; border-radius: 8px; overflow-x: auto; }
    .badge { display: inline-block; padding: 4px 8px; border-radius: 12px; background: #e0f2fe; color: #0369a1; font-size: 12px; font-weight: 700; }
    .panel { border: 1px solid #e2e8f0; border-radius: 10px; padding: 12px; margin-bottom: 8px; background: #f8fafc; }
    .panel h4 { margin: 0 0 6px; }
    .divider { height: 1px; background: #e2e8f0; margin: 12px 0; }
    code.inline { background: #e2e8f0; padding: 2px 4px; border-radius: 4px; }

    /* ç»“æœå±•ç¤ºä¼˜åŒ–æ ·å¼ */
    .result-container { margin-top: 16px; }
    .result-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
    .result-title { font-size: 18px; font-weight: 600; color: #1f2937; margin: 0; }
    .confidence-bar { width: 100%; height: 8px; background: #e5e7eb; border-radius: 4px; overflow: hidden; margin: 8px 0; }
    .confidence-fill { height: 100%; border-radius: 4px; transition: width 0.3s ease; }
    .confidence-high { background: linear-gradient(90deg, #10b981, #059669); }
    .confidence-medium { background: linear-gradient(90deg, #f59e0b, #d97706); }
    .confidence-low { background: linear-gradient(90deg, #ef4444, #dc2626); }

    .result-content { padding: 0; }
    .result-section { margin-bottom: 16px; }
    .result-section:last-child { margin-bottom: 0; }
    .section-title { font-size: 14px; font-weight: 600; color: #374151; margin-bottom: 8px; display: flex; align-items: center; }
    .section-icon { margin-right: 8px; font-size: 16px; }
    .section-content { color: #4b5563; line-height: 1.6; padding-left: 24px; }

    .analysis-item { margin-bottom: 12px; padding: 12px; background: #f9fafb; border-radius: 6px; border-left: 3px solid #3b82f6; }
    .analysis-label { font-weight: 600; color: #1f2937; margin-bottom: 4px; }
    .analysis-text { color: #4b5563; line-height: 1.5; }

    .highlight { background: #fef3c7; padding: 2px 4px; border-radius: 3px; font-weight: 500; }
    .warning { background: #fee2e2; padding: 2px 4px; border-radius: 3px; font-weight: 500; color: #dc2626; }
    .success { background: #d1fae5; padding: 2px 4px; border-radius: 3px; font-weight: 500; color: #059669; }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  </script>
</head>
<body>
  <header>
    <h2>AI äº§å“æ–‡æ¡£å®¡æŸ¥ï¼ˆçº¯å‰ç«¯ç‰ˆæœ¬ï¼‰</h2>
  </header>
  <main>
    <section class="card">
      <h3>æ­¥éª¤ 1ï¼šé…ç½® API å¯†é’¥å¹¶ä¸Šä¼  PDF</h3>
      <div class="flex" style="margin-bottom: 8px;">
        <select id="apiProvider" style="padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; margin-right: 8px;">
          <option value="openai">OpenAI GPT-4o-mini</option>
          <option value="deepseek">DeepSeek</option>
          <option value="custom">è‡ªå®šä¹‰API</option>
        </select>
        <input type="password" id="apiKeyInput" placeholder="è¾“å…¥ API å¯†é’¥" style="flex: 1; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px;" />
        <button class="btn" id="saveKeyBtn">ä¿å­˜å¯†é’¥</button>
      </div>
      <div id="customApiSettings" style="display: none; margin-bottom: 8px;">
        <div class="flex">
          <input type="text" id="customApiUrl" placeholder="APIç«¯ç‚¹URL" style="flex: 1; padding: 6px; border: 1px solid #d1d5db; border-radius: 4px; margin-right: 4px;" />
          <input type="text" id="customModel" placeholder="æ¨¡å‹åç§°" value="gpt-4o-mini" style="flex: 1; padding: 6px; border: 1px solid #d1d5db; border-radius: 4px;" />
        </div>
      </div>
      <div class="flex">
        <input type="file" id="fileInput" accept="application/pdf" />
        <button class="btn" id="startBtn" disabled>å¼€å§‹åˆ†æ</button>
        <span id="fileInfo" class="badge">æœªé€‰æ‹©æ–‡ä»¶</span>
      </div>
      <div class="divider"></div>
      <div class="progress-bar"><div id="progress" class="progress"></div></div>
      <ul class="status-list" id="statusList"></ul>
    </section>

    <section class="card">
      <h3>æ­¥éª¤ 2ï¼šç»“æœé¢æ¿</h3>
      <div class="tabs" id="tabs"></div>
      <div id="resultPanel" class="panel">æš‚æ— ç»“æœï¼Œè¯·å…ˆä¸Šä¼ å¹¶åˆ†æã€‚</div>
      <div id="docStats" class="panel" style="display: none; margin-top: 12px;">
        <h4>æ–‡æ¡£å¤„ç†ç»Ÿè®¡</h4>
        <div style="display: flex; gap: 16px; flex-wrap: wrap;">
          <div class="badge" id="docLength">æ–‡æ¡£é•¿åº¦: --</div>
          <div class="badge" id="chunkCount">åˆ†å—æ•°é‡: --</div>
          <div class="badge" id="avgChunkSize">å¹³å‡å—å¤§å°: --</div>
        </div>
      </div>

      <div id="tokenUsage" class="panel" style="display: none; margin-top: 12px;">
        <h4>Token ä½¿ç”¨æƒ…å†µ</h4>
        <div style="display: flex; gap: 16px; flex-wrap: wrap;">
          <div class="badge" id="promptTokens">è¾“å…¥: --</div>
          <div class="badge" id="completionTokens">è¾“å‡º: --</div>
          <div class="badge" id="totalTokens">æ€»è®¡: --</div>
        </div>
      </div>
      <div class="divider"></div>
      <div class="flex">
        <button class="btn" id="testConnection">æµ‹è¯•è¿æ¥</button>
        <button class="btn" id="exportJson" disabled>å¯¼å‡º JSON</button>
        <button class="btn" id="copySummary" disabled>å¤åˆ¶æ‘˜è¦</button>
        <button class="btn" id="rerun" disabled>é‡æ–°åˆ†æ</button>
      </div>
    </section>

    <section class="card">
      <h3>API è¯·æ±‚ç¤ºä¾‹</h3>
      <pre id="apiRequestPreview"></pre>

      <h3>ç½‘ç»œè¯Šæ–­</h3>
      <div class="panel">
        <div class="flex" style="margin-bottom: 12px;">
          <button class="btn" id="testNetwork">æµ‹è¯•ç½‘ç»œè¿æ¥</button>
          <span id="networkStatus" class="badge">æœªæµ‹è¯•</span>
        </div>

        <p><strong>å¸¸è§ç½‘ç»œé—®é¢˜è§£å†³æ–¹æ¡ˆï¼š</strong></p>
        <ul>
          <li>ğŸ”¸ <strong>ä¸­å›½å¤§é™†ç”¨æˆ·</strong>ï¼šOpenAI APIå¯èƒ½è¢«å±è”½ï¼Œå»ºè®®ä½¿ç”¨VPN</li>
          <li>ğŸ”¸ <strong>VPNé€‰æ‹©</strong>ï¼šé¦™æ¸¯/æ–°åŠ å¡/æ—¥æœ¬/ç¾å›½è¥¿éƒ¨èŠ‚ç‚¹é€šå¸¸å¯ç”¨</li>
          <li>ğŸ”¸ <strong>é˜²ç«å¢™</strong>ï¼šæ£€æŸ¥æ˜¯å¦é˜»æ­¢äº†api.openai.com (443ç«¯å£)</li>
          <li>ğŸ”¸ <strong>ä»£ç†è®¾ç½®</strong>ï¼šæµè§ˆå™¨å¯èƒ½éœ€è¦é…ç½®ä»£ç†</li>
        </ul>

        <p><strong>æ›¿ä»£æ–¹æ¡ˆï¼š</strong></p>
        <ul>
          <li>ğŸ”¸ <strong>DeepSeek</strong>ï¼šå†…ç½®æ”¯æŒï¼Œæ— éœ€é¢å¤–é…ç½®</li>
          <li>ğŸ”¸ <strong>å…¶ä»–æœåŠ¡</strong>ï¼šæ–‡å¿ƒä¸€è¨€ã€æ™ºè°±AIã€é€šä¹‰åƒé—®ç­‰</li>
          <li>ğŸ”¸ <strong>æœ¬åœ°éƒ¨ç½²</strong>ï¼šOllama + å¼€æºæ¨¡å‹</li>
          <li>ğŸ”¸ <strong>ä»£ç†æœåŠ¡</strong>ï¼šéƒ¨ç½²åç«¯ä¸­è½¬APIè¯·æ±‚</li>
        </ul>
      </div>
    </section>
  </main>

  <script>
    // PDF.js åˆå§‹åŒ–
    // è®¾ç½®PDF.js workerè·¯å¾„ï¼Œå¸¦å¤‡ç”¨æ–¹æ¡ˆ
    try {
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.6.82/build/pdf.worker.min.js';
    } catch (e) {
      console.warn('Setting PDF.js worker failed:', e);
      try {
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@4.6.82/build/pdf.worker.min.js';
      } catch (e2) {
        console.error('PDF.js worker setup failed completely:', e2);
      }
    }

    // ç­‰å¾…DOMåŠ è½½å®Œæˆ
    document.addEventListener('DOMContentLoaded', function() {
      console.log('DOM loaded, initializing application...');

      // PDF.js åˆå§‹åŒ–
      try {
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        console.log('PDF.js worker configured successfully');
      } catch (e) {
        console.warn('Setting PDF.js worker failed:', e);
      }

      initializeApp();
    });

    // å°†æ‰€æœ‰åˆå§‹åŒ–ä»£ç ç§»åˆ°è¿™ä¸ªå‡½æ•°ä¸­
    function initializeApp() {
      console.log('Initializing application...');

      const fileInput = document.getElementById('fileInput');
      const startBtn = document.getElementById('startBtn');
      const statusList = document.getElementById('statusList');
      const progressEl = document.getElementById('progress');
      const tabsEl = document.getElementById('tabs');
      const resultPanel = document.getElementById('resultPanel');
      const fileInfo = document.getElementById('fileInfo');
      const apiRequestPreview = document.getElementById('apiRequestPreview');
      const exportJsonBtn = document.getElementById('exportJson');
      const copySummaryBtn = document.getElementById('copySummary');
      const rerunBtn = document.getElementById('rerun');
      const testConnectionBtn = document.getElementById('testConnection');
      const testNetworkBtn = document.getElementById('testNetwork');
      const networkStatus = document.getElementById('networkStatus');
      const apiProvider = document.getElementById('apiProvider');
      const customApiSettings = document.getElementById('customApiSettings');
      const customApiUrl = document.getElementById('customApiUrl');
      const customModel = document.getElementById('customModel');
      const apiKeyInput = document.getElementById('apiKeyInput');
      const saveKeyBtn = document.getElementById('saveKeyBtn');

      let extractedText = '';
      let lastResult = null;
      let currentFile = null;
      let apiKey = localStorage.getItem('openai_api_key') || '';

      // åˆå§‹åŒ–APIè®¾ç½®
      const savedProvider = localStorage.getItem('api_provider') || 'openai';
      const savedApiUrl = localStorage.getItem('custom_api_url') || '';
      const savedModel = localStorage.getItem('custom_model') || 'gpt-4o-mini';

      apiProvider.value = savedProvider;
      customApiUrl.value = savedApiUrl;
      customModel.value = savedModel;

      // æ˜¾ç¤º/éšè—è‡ªå®šä¹‰APIè®¾ç½®ï¼Œå¹¶è‡ªåŠ¨å¡«å……é¢„è®¾å€¼
      function updateApiSettings() {
        const provider = apiProvider.value;
        if (provider === 'deepseek') {
          customApiUrl.value = 'https://api.deepseek.com/v1/chat/completions';
          customModel.value = 'deepseek-chat';
          customApiSettings.style.display = 'none'; // DeepSeekä½¿ç”¨å›ºå®šé…ç½®
        } else if (provider === 'custom') {
          customApiSettings.style.display = 'block';
        } else {
          customApiSettings.style.display = 'none';
        }
      }

      apiProvider.addEventListener('change', function() {
        localStorage.setItem('api_provider', this.value);
        updateApiSettings();
        // åˆ‡æ¢APIæä¾›å•†æ—¶å¯ç”¨ä¿å­˜æŒ‰é’®
        if (saveKeyBtn.disabled) {
          saveKeyBtn.textContent = 'ä¿å­˜è®¾ç½®';
          saveKeyBtn.disabled = false;
        }
      });

      updateApiSettings();

      // åˆå§‹åŒ–APIå¯†é’¥è¾“å…¥æ¡†
      apiKeyInput.value = apiKey;
      if (apiKey) {
        saveKeyBtn.textContent = 'å·²ä¿å­˜';
        saveKeyBtn.disabled = true;
      }

      // å½“ç”¨æˆ·ä¿®æ”¹APIå¯†é’¥è¾“å…¥æ¡†æ—¶ï¼Œå¯ç”¨ä¿å­˜æŒ‰é’®
      apiKeyInput.addEventListener('input', () => {
        if (saveKeyBtn.disabled) {
          saveKeyBtn.textContent = 'ä¿å­˜å¯†é’¥';
          saveKeyBtn.disabled = false;
        }
      });

      // å½“ç”¨æˆ·ä¿®æ”¹è‡ªå®šä¹‰APIè®¾ç½®æ—¶ï¼Œä¹Ÿå¯ç”¨ä¿å­˜æŒ‰é’®
      customApiUrl.addEventListener('input', () => {
        if (saveKeyBtn.disabled) {
          saveKeyBtn.textContent = 'ä¿å­˜è®¾ç½®';
          saveKeyBtn.disabled = false;
        }
      });

      customModel.addEventListener('input', () => {
        if (saveKeyBtn.disabled) {
          saveKeyBtn.textContent = 'ä¿å­˜è®¾ç½®';
          saveKeyBtn.disabled = false;
        }
      });

      // åˆå§‹åŒ–æŒ‰é’®çŠ¶æ€
      startBtn.disabled = !canStartAnalysis();

    const steps = [
      { label: 'è§£æ PDF æ–‡æ¡£', progress: 8 },
      { label: 'AI åˆ†ææ–‡æ¡£ç»“æ„', progress: 15 },
      { label: 'AI åˆ†æä¸­ - è®¾è®¡ç¼ºé™·æ£€æŸ¥', progress: 35 },
      { label: 'AI åˆ†æä¸­ - é€»è¾‘ä¸€è‡´æ€§åˆ†æ', progress: 55 },
      { label: 'AI åˆ†æä¸­ - æŠ€æœ¯æ–¹æ¡ˆå»ºè®®', progress: 75 },
      { label: 'AI åˆ†æä¸­ - é£é™©è¯„ä¼°', progress: 95 },
      { label: 'ç”Ÿæˆå¯è§†åŒ–æŠ¥å‘Š', progress: 100 },
    ];

    // AIæ™ºèƒ½æ–‡æ¡£åˆ†æå’Œåˆ†å—ç­–ç•¥
    const documentProcessor = {
      // ä½¿ç”¨AIåˆ†ææ–‡æ¡£ç»“æ„å¹¶åˆ†å—
      async analyzeDocumentStructure(text) {
        const analysisPrompt = `è¯·åˆ†æä»¥ä¸‹äº§å“æ–‡æ¡£ï¼Œè¯†åˆ«æ–‡æ¡£ç»“æ„å¹¶å°†å…¶åˆ†æˆæœ‰é€»è¾‘æ„ä¹‰çš„æ®µè½å—ã€‚è¿”å›JSONæ ¼å¼ï¼š

æ–‡æ¡£å†…å®¹:
${text.substring(0, 8000)}

è¯·è¿”å›ä»¥ä¸‹ç»“æ„çš„JSONï¼š
{
  "document_summary": "æ–‡æ¡£æ•´ä½“æ‘˜è¦ï¼ˆ100å­—ä»¥å†…ï¼‰",
  "sections": [
    {
      "id": "section_1",
      "title": "æ®µè½æ ‡é¢˜/ä¸»é¢˜",
      "content": "æ®µè½å®Œæ•´å†…å®¹",
      "category": "åŠŸèƒ½æè¿°|è®¾è®¡è¯´æ˜|æŠ€æœ¯å®ç°|é£é™©è¯„ä¼°|å…¶ä»–",
      "relevance": {
        "è®¾è®¡ç¼ºé™·æ£€æŸ¥": 0-10çš„ç›¸å…³åº¦è¯„åˆ†,
        "é€»è¾‘ä¸€è‡´æ€§åˆ†æ": 0-10çš„ç›¸å…³åº¦è¯„åˆ†,
        "æŠ€æœ¯æ–¹æ¡ˆå»ºè®®": 0-10çš„ç›¸å…³åº¦è¯„åˆ†,
        "é£é™©è¯„ä¼°": 0-10çš„ç›¸å…³åº¦è¯„åˆ†
      }
    }
  ],
  "metadata": {
    "total_sections": 0,
    "total_length": 0
  }
}`;

        const provider = apiProvider.value;
        let apiUrl = 'https://api.openai.com/v1/chat/completions';
        let model = 'gpt-4o-mini';

        if (provider === 'deepseek') {
          apiUrl = 'https://api.deepseek.com/v1/chat/completions';
          model = 'deepseek-chat';
        } else if (provider === 'custom') {
          apiUrl = customApiUrl.value;
          model = customModel.value;
        }

        const payload = {
          model: model,
          temperature: 0.1,
          messages: [
            { role: 'system', content: 'ä½ æ˜¯ä¸€ä¸ªæ–‡æ¡£ç»“æ„åˆ†æä¸“å®¶ï¼Œè¯·è¿”å›çº¯JSONæ ¼å¼ã€‚' },
            { role: 'user', content: analysisPrompt },
          ],
        };

        try {
          const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${apiKey}`,
            },
            body: JSON.stringify(payload),
          });

          if (!response.ok) {
            throw new Error(`æ–‡æ¡£åˆ†æå¤±è´¥: ${response.status}`);
          }

          const data = await response.json();
          let contentStr = data.choices[0].message.content;

          // æ¸…ç†å¯èƒ½çš„markdownä»£ç å—æ ¼å¼
          if (contentStr.startsWith('```json')) {
            contentStr = contentStr.replace(/^```json\s*/, '').replace(/\s*```$/, '');
          } else if (contentStr.startsWith('```')) {
            // å¤„ç†å…¶ä»–ä»£ç å—æ ¼å¼
            contentStr = contentStr.replace(/^```\s*/, '').replace(/\s*```$/, '');
          }

          const result = JSON.parse(contentStr.trim());

          return {
            ...result,
            usage: data.usage,
            originalText: text
          };
        } catch (error) {
          console.error('AIæ–‡æ¡£åˆ†æå¤±è´¥:', error);
          // å¦‚æœæ˜¯JSONè§£æé”™è¯¯ï¼Œå°è¯•é™çº§å¤„ç†
          if (error instanceof SyntaxError && error.message.includes('JSON')) {
            console.warn('å°è¯•ä¿®å¤JSONè§£æé”™è¯¯...');
            try {
              // å†æ¬¡å°è¯•æ¸…ç†å¹¶è§£æ
              let fixedContent = data.choices[0].message.content;
              // æ›´æ¿€è¿›çš„æ¸…ç†
              fixedContent = fixedContent.replace(/```json\s*/g, '').replace(/```\s*$/g, '');
              fixedContent = fixedContent.replace(/```\w*\s*/g, '').replace(/```\s*$/g, '');
              fixedContent = fixedContent.trim();

              const result = JSON.parse(fixedContent);
              console.log('JSONè§£æä¿®å¤æˆåŠŸ');
              return {
                ...result,
                usage: data.usage,
                originalText: text
              };
            } catch (fixError) {
              console.error('JSONè§£æä¿®å¤å¤±è´¥:', fixError);
            }
          }
          // é™çº§åˆ°ä¼ ç»Ÿåˆ†å—æ–¹æ³•
          return this.fallbackChunking(text);
        }
      },

      // é™çº§æ–¹æ¡ˆï¼šä¼ ç»Ÿåˆ†å—æ–¹æ³•
      fallbackChunking(text) {
        const paragraphs = text.split('\n\n').filter(p => p.trim().length > 100);
        const chunks = [];
        let currentChunk = '';
        let sectionId = 1;

        for (const paragraph of paragraphs) {
          if ((currentChunk + paragraph).length > 2000 && currentChunk.length > 0) {
            chunks.push({
              id: `fallback_${sectionId}`,
              title: `æ–‡æ¡£æ®µè½ ${sectionId}`,
              content: currentChunk.trim(),
              category: 'å…¶ä»–',
              relevance: {
                'è®¾è®¡ç¼ºé™·æ£€æŸ¥': 5,
                'é€»è¾‘ä¸€è‡´æ€§åˆ†æ': 5,
                'æŠ€æœ¯æ–¹æ¡ˆå»ºè®®': 5,
                'é£é™©è¯„ä¼°': 5
              }
            });
            sectionId++;
            currentChunk = paragraph;
          } else {
            currentChunk += '\n\n' + paragraph;
          }
        }

        if (currentChunk.trim()) {
          chunks.push({
            id: `fallback_${sectionId}`,
            title: `æ–‡æ¡£æ®µè½ ${sectionId}`,
            content: currentChunk.trim(),
            category: 'å…¶ä»–',
            relevance: {
              'è®¾è®¡ç¼ºé™·æ£€æŸ¥': 5,
              'é€»è¾‘ä¸€è‡´æ€§åˆ†æ': 5,
              'æŠ€æœ¯æ–¹æ¡ˆå»ºè®®': 5,
              'é£é™©è¯„ä¼°': 5
            }
          });
        }

        return {
          document_summary: 'æ–‡æ¡£åˆ†æå¤±è´¥ï¼Œä½¿ç”¨ä¼ ç»Ÿåˆ†å—æ–¹æ³•',
          sections: chunks,
          metadata: {
            total_sections: chunks.length,
            total_length: text.length
          },
          usage: null,
          originalText: text
        };
      },

      // æ ¹æ®åˆ†æç±»å‹é€‰æ‹©æœ€ç›¸å…³çš„æ®µè½
      getRelevantSections(processedDoc, analysisType) {
        const { sections } = processedDoc;
        const analysisKey = analysisType.key;

        // æŒ‰ç›¸å…³åº¦æ’åº
        const sortedSections = sections
          .filter(section => section.relevance && section.relevance[analysisKey] > 0)
          .sort((a, b) => (b.relevance[analysisKey] || 0) - (a.relevance[analysisKey] || 0));

        // é€‰æ‹©å‰3ä¸ªæœ€ç›¸å…³çš„æ®µè½
        const topSections = sortedSections.slice(0, 3);

        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°è¶³å¤Ÿçš„ç›¸å…³æ®µè½ï¼Œè¡¥å……ä¸€äº›é€šç”¨æ®µè½
        if (topSections.length < 2) {
          const generalSections = sections
            .filter(section => !topSections.includes(section))
            .slice(0, 2 - topSections.length);
          topSections.push(...generalSections);
        }

        return topSections;
      },

      // ç”Ÿæˆæ®µè½ç»„åˆå†…å®¹
      generateContentForAnalysis(sections, maxLength = 3000) {
        const combinedContent = sections
          .map(section => `[${section.title}]\n${section.content}`)
          .join('\n\n---\n\n');

        // å¦‚æœå†…å®¹è¿‡é•¿ï¼Œè¿›è¡Œæ™ºèƒ½æˆªæ–­
        if (combinedContent.length > maxLength) {
          const truncated = combinedContent.substring(0, maxLength);
          const lastSectionBreak = truncated.lastIndexOf('\n\n---\n\n');
          if (lastSectionBreak > maxLength * 0.7) {
            return truncated.substring(0, lastSectionBreak) + '\n\n[å†…å®¹å·²æˆªæ–­ä»¥æ§åˆ¶tokenæ¶ˆè€—]';
          }
          return truncated + '\n\n[å†…å®¹å·²æˆªæ–­ä»¥æ§åˆ¶tokenæ¶ˆè€—]';
        }

        return combinedContent;
      }
    };

    const analysisTypes = [
      {
        key: 'è®¾è®¡ç¼ºé™·æ£€æŸ¥',
        name: 'è®¾è®¡ç¼ºé™·æ£€æŸ¥',
        prompt: 'è¯·åŸºäºæä¾›çš„æ–‡æ¡£ç‰‡æ®µåˆ†æè®¾è®¡ç¼ºé™·ï¼Œé‡ç‚¹å…³æ³¨UI/UXå’Œäº¤äº’é€»è¾‘é—®é¢˜ã€‚',
        maxContentLength: 3000
      },
      {
        key: 'é€»è¾‘ä¸€è‡´æ€§åˆ†æ',
        name: 'é€»è¾‘ä¸€è‡´æ€§åˆ†æ',
        prompt: 'è¯·åŸºäºæä¾›çš„æ–‡æ¡£ç‰‡æ®µåˆ†æé€»è¾‘ä¸€è‡´æ€§ï¼Œæ£€æŸ¥æ˜¯å¦å­˜åœ¨çŸ›ç›¾æˆ–ä¸ä¸€è‡´çš„åœ°æ–¹ã€‚',
        maxContentLength: 2500
      },
      {
        key: 'æŠ€æœ¯æ–¹æ¡ˆå»ºè®®',
        name: 'æŠ€æœ¯æ–¹æ¡ˆå»ºè®®',
        prompt: 'è¯·åŸºäºæä¾›çš„æ–‡æ¡£ç‰‡æ®µæå‡ºæŠ€æœ¯å®ç°æ–¹æ¡ˆå»ºè®®ã€‚',
        maxContentLength: 3500
      },
      {
        key: 'é£é™©è¯„ä¼°',
        name: 'é£é™©è¯„ä¼°',
        prompt: 'è¯·åŸºäºæä¾›çš„æ–‡æ¡£ç‰‡æ®µè¯„ä¼°æ½œåœ¨é£é™©å’ŒæŠ€æœ¯å€ºåŠ¡ã€‚',
        maxContentLength: 2000
      }
    ];

    // ä¿å­˜APIè®¾ç½®
    saveKeyBtn.addEventListener('click', () => {
      const key = apiKeyInput.value.trim();
      if (!key) {
        alert('è¯·è¾“å…¥æœ‰æ•ˆçš„ API å¯†é’¥');
        return;
      }

      // ä¿å­˜APIè®¾ç½®
      apiKey = key;
      localStorage.setItem('openai_api_key', key);

      // ä¿å­˜è‡ªå®šä¹‰APIè®¾ç½®
      localStorage.setItem('custom_api_url', customApiUrl.value);
      localStorage.setItem('custom_model', customModel.value);

      saveKeyBtn.textContent = 'å·²ä¿å­˜';
      saveKeyBtn.disabled = true;

      const provider = apiProvider.value;
      const providerName = provider === 'openai' ? 'OpenAI' :
                          provider === 'deepseek' ? 'DeepSeek' : 'è‡ªå®šä¹‰API';
      alert(`${providerName} è®¾ç½®å·²ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨`);

      // æ›´æ–°å¼€å§‹åˆ†ææŒ‰é’®çŠ¶æ€
      startBtn.disabled = !canStartAnalysis();
    });

      // æ£€æŸ¥æ˜¯å¦å¯ä»¥å¼€å§‹åˆ†æ
      function canStartAnalysis() {
        return currentFile && apiKey;
      }

      console.log('Elements initialized, setting up event listeners...');

    fileInput.addEventListener('change', (e) => {
      console.log('File input change event triggered', e.target.files);
      const file = e.target.files?.[0];
      if (!file) {
        console.log('No file selected');
        startBtn.disabled = true;
        fileInfo.textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
        fileInfo.className = 'badge';
        return;
      }

      console.log('File selected:', file.name, 'Type:', file.type, 'Size:', file.size);

      // æ£€æŸ¥æ–‡ä»¶ç±»å‹
      if (file.type !== 'application/pdf') {
        console.log('Invalid file type:', file.type);
        alert('ä»…æ”¯æŒ PDF æ–‡ä»¶');
        startBtn.disabled = true;
        fileInfo.textContent = 'æ–‡ä»¶ç±»å‹é”™è¯¯ï¼ˆä»…æ”¯æŒPDFï¼‰';
        fileInfo.className = 'badge';
        fileInfo.style.background = '#fecaca';
        fileInfo.style.color = '#dc2626';
        return;
      }

      // æ£€æŸ¥æ–‡ä»¶å¤§å°
      if (file.size > 20 * 1024 * 1024) {
        console.log('File too large:', file.size);
        alert('æ–‡ä»¶å¤§å°è¯·æ§åˆ¶åœ¨ 20MB ä»¥å†…');
        startBtn.disabled = true;
        fileInfo.textContent = 'æ–‡ä»¶è¿‡å¤§ï¼ˆæœ€å¤§20MBï¼‰';
        fileInfo.className = 'badge';
        fileInfo.style.background = '#fecaca';
        fileInfo.style.color = '#dc2626';
        return;
      }

      currentFile = file;
      fileInfo.textContent = `${file.name} / ${(file.size / 1024 / 1024).toFixed(2)} MB`;
      fileInfo.className = 'badge';
      fileInfo.style.background = '';
      fileInfo.style.color = '';

      const canStart = canStartAnalysis();
      console.log('File selected:', file.name, 'Can start:', canStart, 'API Key exists:', !!apiKey);
      startBtn.disabled = !canStart;

      // å¦‚æœæœ‰APIå¯†é’¥ä½†æŒ‰é’®ä»è¢«ç¦ç”¨ï¼Œæ˜¾ç¤ºæç¤º
      if (!canStart && apiKey) {
        console.log('API key exists but start button disabled - check canStartAnalysis logic');
      }
    });

    startBtn.addEventListener('click', async () => {
      if (!canStartAnalysis()) return;
      resetUI();
      try {
        logStep(steps[0].label, steps[0].progress);
        extractedText = await parsePdf(currentFile);

        // AIæ™ºèƒ½æ–‡æ¡£ç»“æ„åˆ†æ
        logStep('AIåˆ†ææ–‡æ¡£ç»“æ„ä¸­...', 15);
        const processedDoc = await documentProcessor.analyzeDocumentStructure(extractedText);
        updateDocStats(processedDoc);
        console.log(`AIå·²åˆ†ææ–‡æ¡£ï¼š${processedDoc.sections.length}ä¸ªæ®µè½ï¼Œæ€»é•¿åº¦ï¼š${processedDoc.metadata.total_length}å­—ç¬¦`);

        // åˆå§‹åŒ–ç»“æœæ”¶é›†
        const allResults = {};
        let totalUsage = processedDoc.usage ? {
          prompt_tokens: processedDoc.usage.prompt_tokens || 0,
          completion_tokens: processedDoc.usage.completion_tokens || 0,
          total_tokens: processedDoc.usage.total_tokens || 0
        } : { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 };

        // æ˜¾ç¤ºé¢„å¤„ç†ç»“æœï¼ˆæ–‡æ¡£ç»“æ„åˆ†æï¼‰
        if (processedDoc.document_summary) {
          allResults['æ–‡æ¡£ç»“æ„åˆ†æ'] = `ğŸ“„ æ–‡æ¡£æ‘˜è¦ï¼š${processedDoc.document_summary}\n\nğŸ“Š åˆ†æç»“æœï¼šå…±è¯†åˆ«${processedDoc.sections.length}ä¸ªæ®µè½ï¼ŒåŒ…æ‹¬ï¼š\n${
            processedDoc.sections.map(s => `â€¢ ${s.title} (${s.category})`).join('\n')
          }`;
          renderTabs(allResults); // ç«‹å³æ˜¾ç¤ºé¢„å¤„ç†ç»“æœ
        }

        // é€ä¸ªåˆ†ææ¯ä¸ªç¯èŠ‚
        for (let i = 0; i < analysisTypes.length; i++) {
          const analysisType = analysisTypes[i];
          const stepIndex = i + 2; // steps[2]å¼€å§‹æ˜¯ç¬¬ä¸€ä¸ªåˆ†ææ­¥éª¤

          logStep(steps[stepIndex].label, steps[stepIndex].progress);

          const payload = buildApiRequest(processedDoc, analysisType);
          if (i === 0) { // åªæ˜¾ç¤ºç¬¬ä¸€ä¸ªè¯·æ±‚çš„é¢„è§ˆ
            apiRequestPreview.textContent = JSON.stringify(payload, null, 2);
          }

          const data = await callApi(payload);

          // åˆå¹¶ç»“æœ
          allResults[analysisType.key] = data.result || data.results?.[analysisType.key] || 'åˆ†æå¤±è´¥';

          // ç´¯åŠ tokenä½¿ç”¨æƒ…å†µ
          if (data.usage) {
            totalUsage.prompt_tokens += data.usage.prompt_tokens || 0;
            totalUsage.completion_tokens += data.usage.completion_tokens || 0;
            totalUsage.total_tokens += data.usage.total_tokens || 0;
          }

          // æ¯ä¸ªåˆ†æå®Œæˆåç«‹å³æ›´æ–°UI
          renderTabs(allResults);
          updateTokenUsage(totalUsage.total_tokens > 0 ? totalUsage : null);
        }

        // ä¿å­˜å®Œæ•´ç»“æœ
        lastResult = {
          success: true,
          analysis_id: crypto.randomUUID(),
          results: allResults,
          metadata: { confidence: 0.8 },
          usage: totalUsage.total_tokens > 0 ? totalUsage : null,
        };

        logStep(steps[6].label, steps[6].progress, true); // æœ€åä¸€æ­¥
        toggleActions(true);
      } catch (err) {
        console.error('Analysis failed:', err);

        let errorMessage = 'åˆ†æå¤±è´¥ï¼š';

        if (err.name === 'AbortError') {
          errorMessage += 'ç½‘ç»œè¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥åé‡è¯•';
        } else if (err.message.includes('Failed to fetch') || err.message.includes('NetworkError')) {
          errorMessage += 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ï¼š\n1. ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸\n2. æ˜¯å¦æœ‰é˜²ç«å¢™é˜»æ­¢è¿æ¥\n3. æ˜¯å¦éœ€è¦é…ç½®ä»£ç†';
        } else if (err.message.includes('CORS')) {
          errorMessage += 'è·¨åŸŸè¯·æ±‚è¢«é˜»æ­¢ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•';
        } else {
          errorMessage += err.message;
        }

        alert(errorMessage);
        toggleActions(false);
      }
    });

    rerunBtn.addEventListener('click', () => startBtn.click());

    exportJsonBtn.addEventListener('click', () => {
      if (!lastResult) return;
      const blob = new Blob([JSON.stringify(lastResult, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `analysis-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
    });

    testConnectionBtn.addEventListener('click', async () => {
      if (!apiKey) {
        alert('è¯·å…ˆè¾“å…¥å¹¶ä¿å­˜APIå¯†é’¥');
        return;
      }

      testConnectionBtn.disabled = true;
      testConnectionBtn.textContent = 'æµ‹è¯•ä¸­...';

      try {
        console.log('Testing API connection...');

        const provider = apiProvider.value;
        let testUrl = 'https://api.openai.com/v1/chat/completions'; // é»˜è®¤OpenAI
        let testModel = 'gpt-4o-mini';

        if (provider === 'deepseek') {
          testUrl = 'https://api.deepseek.com/v1/chat/completions';
          testModel = 'deepseek-chat';
        } else if (provider === 'custom') {
          testUrl = customApiUrl.value;
          testModel = customModel.value;
        }

        const testPayload = {
          model: testModel,
          messages: [{ role: 'user', content: 'Hello' }],
          max_tokens: 5
        };

        const headers = {
          'Content-Type': 'application/json',
        };

        if (provider === 'custom') {
          if (apiKey) {
            headers['Authorization'] = `Bearer ${apiKey}`;
          }
        } else {
          headers['Authorization'] = `Bearer ${apiKey}`;
        }

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10ç§’è¶…æ—¶ç”¨äºæµ‹è¯•

        const response = await fetch(testUrl, {
          method: 'POST',
          headers: headers,
          body: JSON.stringify(testPayload),
          signal: controller.signal,
        });

        clearTimeout(timeoutId);

        if (response.ok) {
          alert('âœ… è¿æ¥æµ‹è¯•æˆåŠŸï¼ç½‘ç»œå’ŒAPIå¯†é’¥éƒ½æ­£å¸¸ã€‚');
          console.log('Connection test successful');
        } else {
          const errorText = await response.text();
          throw new Error(`APIè¿”å›é”™è¯¯ ${response.status}: ${errorText}`);
        }

      } catch (err) {
        console.error('Connection test failed:', err);

        let errorMessage = 'âŒ è¿æ¥æµ‹è¯•å¤±è´¥ï¼š\n\n';

        if (err.name === 'AbortError') {
          errorMessage += 'ç½‘ç»œè¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥';
        } else if (err.message.includes('Failed to fetch') || err.message.includes('NetworkError')) {
          errorMessage += 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œå¯èƒ½æ˜¯ï¼š\nâ€¢ ç½‘ç»œè¿æ¥é—®é¢˜\nâ€¢ é˜²ç«å¢™é˜»æ­¢\nâ€¢ éœ€è¦é…ç½®ä»£ç†\nâ€¢ DNSè§£æé—®é¢˜';
        } else if (err.message.includes('401')) {
          errorMessage += 'APIå¯†é’¥æ— æ•ˆï¼Œè¯·æ£€æŸ¥å¯†é’¥æ˜¯å¦æ­£ç¡®';
        } else if (err.message.includes('429')) {
          errorMessage += 'è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•';
        } else {
          errorMessage += err.message;
        }

        alert(errorMessage);
      } finally {
        testConnectionBtn.disabled = false;
        testConnectionBtn.textContent = 'æµ‹è¯•è¿æ¥';
      }
    });

    testNetworkBtn.addEventListener('click', async () => {
      testNetworkBtn.disabled = true;
      testNetworkBtn.textContent = 'æµ‹è¯•ä¸­...';
      networkStatus.textContent = 'æµ‹è¯•ä¸­...';
      networkStatus.style.background = '#e0f2fe';
      networkStatus.style.color = '#0369a1';

      const testUrls = [
        'https://httpbin.org/get',
        'https://jsonplaceholder.typicode.com/posts/1',
        'https://api.github.com/zen'
      ];

      let successCount = 0;
      let errorMessages = [];

      for (const url of testUrls) {
        try {
          console.log(`Testing connection to: ${url}`);
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 5000);

          const response = await fetch(url, {
            method: 'GET',
            signal: controller.signal,
          });

          clearTimeout(timeoutId);

          if (response.ok) {
            successCount++;
            console.log(`âœ… ${url} - Success (${response.status})`);
          } else {
            errorMessages.push(`${url}: HTTP ${response.status}`);
            console.log(`âŒ ${url} - Failed (${response.status})`);
          }
        } catch (error) {
          errorMessages.push(`${url}: ${error.message}`);
          console.log(`âŒ ${url} - Error: ${error.message}`);
        }
      }

      // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
      testNetworkBtn.disabled = false;
      testNetworkBtn.textContent = 'æµ‹è¯•ç½‘ç»œè¿æ¥';

      if (successCount === testUrls.length) {
        networkStatus.textContent = 'âœ… ç½‘ç»œæ­£å¸¸';
        networkStatus.style.background = '#dcfce7';
        networkStatus.style.color = '#166534';
        alert('ç½‘ç»œè¿æ¥æµ‹è¯•é€šè¿‡ï¼å¦‚æœOpenAI APIä»ç„¶å¤±è´¥ï¼Œå¯èƒ½æ˜¯åœ°åŒºé™åˆ¶æˆ–APIå¯†é’¥é—®é¢˜ã€‚');
      } else if (successCount > 0) {
        networkStatus.textContent = 'âš ï¸ ç½‘ç»œéƒ¨åˆ†å¯ç”¨';
        networkStatus.style.background = '#fef3c7';
        networkStatus.style.color = '#92400e';
        alert(`ç½‘ç»œéƒ¨åˆ†å¯ç”¨ï¼ˆ${successCount}/${testUrls.length}æˆåŠŸï¼‰ã€‚OpenAI APIå¯èƒ½è¢«åœ°åŒºé™åˆ¶ã€‚`);
      } else {
        networkStatus.textContent = 'âŒ ç½‘ç»œè¿æ¥å¤±è´¥';
        networkStatus.style.background = '#fecaca';
        networkStatus.style.color = '#dc2626';
        alert('ç½‘ç»œè¿æ¥å®Œå…¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè®¾ç½®æˆ–ä½¿ç”¨VPNã€‚');
      }

      if (errorMessages.length > 0) {
        console.log('Network test errors:', errorMessages);
      }
    });

    copySummaryBtn.addEventListener('click', async () => {
      if (!lastResult) return;
      const summary = JSON.stringify(lastResult.results || {}, null, 2);
      await navigator.clipboard.writeText(summary);
      alert('å·²å¤åˆ¶æ‘˜è¦');
    });

    function resetUI() {
      statusList.innerHTML = '';
      progressEl.style.width = '0%';
      resultPanel.textContent = 'åˆ†æä¸­...';
      tabsEl.innerHTML = '';
      lastResult = null;
      toggleActions(false);
      updateDocStats(null); // éšè—æ–‡æ¡£ç»Ÿè®¡
      updateTokenUsage(null); // éšè—tokenä½¿ç”¨æƒ…å†µ
    }

    function toggleActions(enabled) {
      exportJsonBtn.disabled = !enabled;
      copySummaryBtn.disabled = !enabled;
      rerunBtn.disabled = !enabled;
    }

    function updateDocStats(processedDoc) {
      const docStatsEl = document.getElementById('docStats');
      const docLengthEl = document.getElementById('docLength');
      const chunkCountEl = document.getElementById('chunkCount');
      const avgChunkSizeEl = document.getElementById('avgChunkSize');

      if (processedDoc && processedDoc.metadata) {
        const totalLength = processedDoc.metadata.total_length || processedDoc.totalLength || 0;
        const sectionCount = processedDoc.metadata.total_sections || processedDoc.sections?.length || 0;
        const avgSize = totalLength > 0 && sectionCount > 0
          ? Math.round(totalLength / sectionCount)
          : 0;

        docLengthEl.textContent = `æ–‡æ¡£é•¿åº¦: ${totalLength.toLocaleString()} å­—ç¬¦`;
        chunkCountEl.textContent = `åˆ†ææ®µè½: ${sectionCount} ä¸ª`;
        avgChunkSizeEl.textContent = `å¹³å‡æ®µè½å¤§å°: ${avgSize.toLocaleString()} å­—ç¬¦`;
        docStatsEl.style.display = 'block';
      } else {
        docStatsEl.style.display = 'none';
      }
    }

    function updateTokenUsage(usage) {
      const tokenUsageEl = document.getElementById('tokenUsage');
      const promptTokensEl = document.getElementById('promptTokens');
      const completionTokensEl = document.getElementById('completionTokens');
      const totalTokensEl = document.getElementById('totalTokens');

      if (usage && usage.total_tokens > 0) {
        promptTokensEl.textContent = `è¾“å…¥: ${usage.prompt_tokens || 0}`;
        completionTokensEl.textContent = `è¾“å‡º: ${usage.completion_tokens || 0}`;
        totalTokensEl.textContent = `æ€»è®¡: ${usage.total_tokens || 0} (å·²ä¼˜åŒ–åˆ†å—å¤„ç†)`;
        tokenUsageEl.style.display = 'block';
      } else {
        tokenUsageEl.style.display = 'none';
      }
    }

    function logStep(text, pct, done = false) {
      const li = document.createElement('li');
      li.textContent = `[${pct}%] ${done ? 'âœ…' : 'â–¶'} ${text}`;
      statusList.appendChild(li);
      progressEl.style.width = `${pct}%`;
    }

    async function parsePdf(file) {
      if (typeof pdfjsLib === 'undefined') {
        throw new Error('PDF.js åº“æœªæ­£ç¡®åŠ è½½ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
      }

      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      let fullText = '';
      for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const content = await page.getTextContent();
        const strings = content.items.map(item => item.str).join(' ');
        fullText += `\n[Page ${i}]\n${strings}\n`;
      }
      return fullText;
    }

    function buildApiRequest(processedDoc, analysisType) {
      // è·å–ä¸å½“å‰åˆ†æç±»å‹æœ€ç›¸å…³çš„æ®µè½
      const relevantSections = documentProcessor.getRelevantSections(processedDoc, analysisType);
      const contentToAnalyze = documentProcessor.generateContentForAnalysis(relevantSections, analysisType.maxContentLength);

      const prompt = `è¯·åŸºäºä»¥ä¸‹æ–‡æ¡£ç‰‡æ®µè¿›è¡Œ${analysisType.name}ï¼Œå¹¶è¿”å›çº¯JSONæ ¼å¼ï¼ˆä¸è¦åŒ…å«markdownä»£ç å—æ ‡è®°ï¼‰ï¼š

åˆ†æè¦æ±‚: ${analysisType.prompt}
å“åº”æ ¼å¼: çº¯JSONï¼Œä¸è¦ä½¿ç”¨\`\`\`jsonä»£ç å—æ ¼å¼

æ–‡æ¡£ç‰‡æ®µ (å·²ç”±AIæ™ºèƒ½åˆ†æå¹¶é€‰æ‹©æœ€ç›¸å…³çš„å†…å®¹):
${contentToAnalyze}

è¯·è¿”å›ä»¥ä¸‹ç»“æ„çš„çº¯JSONï¼ˆç›´æ¥ä»¥{å¼€å¤´ï¼Œä¸è¦ä»»ä½•markdownæ ¼å¼ï¼‰ï¼š
{
  "result": "è¯¦ç»†çš„${analysisType.name}åˆ†æå†…å®¹...",
  "confidence": 0.85
}`;

      const provider = apiProvider.value;
      let model = 'gpt-4o-mini'; // é»˜è®¤OpenAI

      if (provider === 'deepseek') {
        model = 'deepseek-chat';
      } else if (provider === 'custom') {
        model = customModel.value;
      }

      return {
        model: model,
        temperature: 0.2,
        messages: [
          { role: 'system', content: 'ä½ æ˜¯äº§å“æ–‡æ¡£å®¡æŸ¥åŠ©æ‰‹ï¼Œè¯·åªè¾“å‡ºçº¯JSONæ ¼å¼ï¼Œä¸è¦åŒ…å«ä»»ä½•markdownä»£ç å—ã€‚' },
          { role: 'user', content: prompt },
        ],
      };
    }

    async function callApi(payload) {
      console.log('Starting API call...');

      const provider = apiProvider.value;
      let apiUrl = 'https://api.openai.com/v1/chat/completions'; // é»˜è®¤OpenAI

      if (provider === 'deepseek') {
        apiUrl = 'https://api.deepseek.com/v1/chat/completions';
      } else if (provider === 'custom') {
        apiUrl = customApiUrl.value;
      }

      console.log(`Using API provider: ${provider}, URL: ${apiUrl}`);

      let contentStr = '{}'; // é»˜è®¤å€¼
      let usage = null; // åˆå§‹åŒ–usageå˜é‡

      try {
        // æ·»åŠ è¶…æ—¶æ§åˆ¶
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000); // 30ç§’è¶…æ—¶

        const headers = {
          'Content-Type': 'application/json',
        };

        // æ ¹æ®æä¾›å•†è®¾ç½®è®¤è¯å¤´
        if (provider === 'custom') {
          // è‡ªå®šä¹‰APIå¯èƒ½ä½¿ç”¨ä¸åŒçš„è®¤è¯æ–¹å¼
          if (apiKey) {
            headers['Authorization'] = `Bearer ${apiKey}`;
          }
        } else {
          // OpenAIæ ‡å‡†è®¤è¯
          headers['Authorization'] = `Bearer ${apiKey}`;
        }

        const response = await fetch(apiUrl, {
          method: 'POST',
          headers: headers,
          body: JSON.stringify(payload),
          signal: controller.signal,
        });

        clearTimeout(timeoutId);

        console.log('OpenAI API response received:', response.status);

        if (!response.ok) {
          let errorText;
          try {
            errorText = await response.text();
          } catch (e) {
            errorText = 'æ— æ³•è¯»å–é”™è¯¯è¯¦æƒ…';
          }
          console.error('OpenAI API error:', response.status, errorText);

          // æ ¹æ®çŠ¶æ€ç æä¾›æ›´å‹å¥½çš„é”™è¯¯ä¿¡æ¯
          let friendlyMessage = '';
          switch (response.status) {
            case 401:
              friendlyMessage = 'APIå¯†é’¥æ— æ•ˆæˆ–è¿‡æœŸï¼Œè¯·æ£€æŸ¥å¯†é’¥';
              break;
            case 403:
              friendlyMessage = 'APIå¯†é’¥æƒé™ä¸è¶³';
              break;
            case 429:
              friendlyMessage = 'è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•';
              break;
            case 500:
            case 502:
            case 503:
              friendlyMessage = 'OpenAIæœåŠ¡å™¨æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·ç¨åå†è¯•';
              break;
            default:
              friendlyMessage = `APIè¯·æ±‚å¤±è´¥ (${response.status})`;
          }

          throw new Error(`${friendlyMessage}: ${errorText}`);
        }

        const data = await response.json();
        contentStr = data?.choices?.[0]?.message?.content || '{}';

        // æå–tokenä½¿ç”¨æƒ…å†µ
        usage = data?.usage || null;

      } catch (error) {
        console.error('OpenAI API request failed:', error);

        // å¦‚æœæ˜¯ç½‘ç»œé”™è¯¯ï¼Œé‡æ–°æŠ›å‡º
        if (error.name === 'AbortError') {
          throw new Error('ç½‘ç»œè¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
        } else if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
          throw new Error('ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œæ— æ³•è¿æ¥åˆ°OpenAIæœåŠ¡å™¨');
        } else {
          // å¦‚æœæ˜¯APIé”™è¯¯ï¼ˆæ¯”å¦‚401ã€429ç­‰ï¼‰ï¼Œæˆ‘ä»¬å·²ç»æœ‰contentStrçš„é»˜è®¤å€¼ï¼Œç»§ç»­å¤„ç†
          console.log('API returned error but continuing with default content');
        }
      }

      try {
        // æ¸…ç†å¯èƒ½çš„markdownä»£ç å—æ ¼å¼
        let cleanContentStr = contentStr.trim();

        // å¦‚æœå†…å®¹ä»¥```jsonå¼€å¤´ï¼Œå»æ‰ä»£ç å—æ ‡è®°
        if (cleanContentStr.startsWith('```json')) {
          cleanContentStr = cleanContentStr.replace(/^```json\s*/, '').replace(/\s*```$/, '');
        } else if (cleanContentStr.startsWith('```')) {
          // å¤„ç†å…¶ä»–ä»£ç å—æ ¼å¼
          cleanContentStr = cleanContentStr.replace(/^```\s*/, '').replace(/\s*```$/, '');
        }

        const parsed = JSON.parse(cleanContentStr);
        return {
          success: true,
          analysis_id: crypto.randomUUID(),
          result: parsed.result || parsed.content || contentStr,
          confidence: parsed.confidence || 0.8,
          usage: usage,
        };
      } catch (e) {
        // å¦‚æœè§£æå¤±è´¥ï¼Œè¿”å›åŸºæœ¬çš„ç»“æ„
        console.warn('JSON parse failed, using raw content:', e);
        return {
          success: true,
          analysis_id: crypto.randomUUID(),
          result: contentStr,
          confidence: 0.6,
          usage: usage,
        };
      }
    }

    let currentResults = {};

    function renderTabs(results = {}) {
      currentResults = results; // ä¿å­˜å½“å‰çš„ç»“æœæ•°æ®
      const completedKeys = Object.keys(results);
      const allKeys = ['æ–‡æ¡£ç»“æ„åˆ†æ', ...analysisTypes.map(t => t.key)];

      tabsEl.innerHTML = '';

      allKeys.forEach((k, idx) => {
        const tab = document.createElement('div');
        const isCompleted = completedKeys.includes(k);
        const isActive = idx === 0 || (!completedKeys.includes(allKeys[0]) && completedKeys.includes(k));

        tab.className = 'tab' + (isActive ? ' active' : '');
        tab.textContent = isCompleted ? k : `${k} (åˆ†æä¸­...)`;
        tab.style.opacity = isCompleted ? '1' : '0.6';
        tab.onclick = () => setActiveTab(k);
        tabsEl.appendChild(tab);
      });

      // å¦‚æœæœ‰ä»»ä½•ç»“æœï¼Œæ˜¾ç¤ºç¬¬ä¸€ä¸ªå®Œæˆçš„æ ‡ç­¾
      const firstCompletedKey = allKeys.find(k => completedKeys.includes(k));
      if (firstCompletedKey) {
        setActiveTab(firstCompletedKey);
      } else {
        resultPanel.innerHTML = '<div class="result-content"><p>AIæ­£åœ¨åˆ†ææ–‡æ¡£ç»“æ„ï¼Œè¯·ç¨å€™...</p></div>';
      }
    }

    function setActiveTab(key) {
      // å¤„ç†å¸¦"(åˆ†æä¸­...)"åç¼€çš„æ ‡ç­¾å
      const cleanKey = key.replace(' (åˆ†æä¸­...)', '');
      [...tabsEl.children].forEach(t => {
        const tabKey = t.textContent.replace(' (åˆ†æä¸­...)', '');
        t.classList.toggle('active', tabKey === cleanKey);
      });

      const data = currentResults?.[cleanKey];

      if (data) {
        resultPanel.innerHTML = `
          <div class="result-content">
            ${renderAnalysisContent(cleanKey, data)}
          </div>
        `;
      } else {
        // æ˜¾ç¤ºç­‰å¾…ä¿¡æ¯
        const waitingMessages = {
          'æ–‡æ¡£ç»“æ„åˆ†æ': 'AIæ­£åœ¨åˆ†ææ–‡æ¡£ç»“æ„å’Œåˆ†å—ï¼Œè¯·ç¨å€™...',
          'è®¾è®¡ç¼ºé™·æ£€æŸ¥': 'æ­£åœ¨æ£€æŸ¥UI/UXè®¾è®¡å’Œäº¤äº’é€»è¾‘ç¼ºé™·...',
          'é€»è¾‘ä¸€è‡´æ€§åˆ†æ': 'æ­£åœ¨åˆ†ææ–‡æ¡£é€»è¾‘ä¸€è‡´æ€§å’Œæ½œåœ¨çŸ›ç›¾...',
          'æŠ€æœ¯æ–¹æ¡ˆå»ºè®®': 'æ­£åœ¨ç”ŸæˆæŠ€æœ¯å®ç°æ–¹æ¡ˆå»ºè®®...',
          'é£é™©è¯„ä¼°': 'æ­£åœ¨è¯„ä¼°æ½œåœ¨é£é™©å’ŒæŠ€æœ¯å€ºåŠ¡...'
        };

        resultPanel.innerHTML = `
          <div class="result-content">
            <div style="text-align: center; padding: 40px; color: #6b7280;">
              <div style="font-size: 48px; margin-bottom: 16px;">â³</div>
              <p style="font-size: 16px; margin: 0;">${waitingMessages[cleanKey] || 'åˆ†æè¿›è¡Œä¸­...'}</p>
            </div>
          </div>
        `;
      }
    }

    function getTabIcon(key) {
      const icons = {
        'è®¾è®¡ç¼ºé™·æ£€æŸ¥': 'ğŸ”',
        'é€»è¾‘ä¸€è‡´æ€§åˆ†æ': 'ğŸ§ ',
        'æŠ€æœ¯æ–¹æ¡ˆå»ºè®®': 'ğŸ’¡',
        'é£é™©è¯„ä¼°': 'âš ï¸'
      };
      return icons[key] || 'ğŸ“‹';
    }

    function getConfidenceClass(confidence) {
      if (confidence >= 0.8) return 'confidence-high';
      if (confidence >= 0.6) return 'confidence-medium';
      return 'confidence-low';
    }

    function renderAnalysisContent(key, data) {
      if (!data) return '<p>æš‚æ— åˆ†æå†…å®¹</p>';

      // å¦‚æœdataæ˜¯å­—ç¬¦ä¸²ï¼Œç›´æ¥æ˜¾ç¤º
      if (typeof data === 'string') {
        return `<div class="result-section">
          <div class="section-content">${formatText(data)}</div>
        </div>`;
      }

      // å¦‚æœdataæ˜¯å¯¹è±¡ï¼Œå°è¯•ç»“æ„åŒ–æ˜¾ç¤º
      if (typeof data === 'object') {
        return renderStructuredContent(key, data);
      }

      return `<div class="result-section">
        <div class="section-content">${data}</div>
      </div>`;
    }

    function renderStructuredContent(key, data) {
      let html = '';

      if (key === 'è®¾è®¡ç¼ºé™·æ£€æŸ¥') {
        html = renderDefectAnalysis(data);
      } else if (key === 'é€»è¾‘ä¸€è‡´æ€§åˆ†æ') {
        html = renderConsistencyAnalysis(data);
      } else if (key === 'æŠ€æœ¯æ–¹æ¡ˆå»ºè®®') {
        html = renderTechnicalSuggestions(data);
      } else if (key === 'é£é™©è¯„ä¼°') {
        html = renderRiskAssessment(data);
      } else {
        // é»˜è®¤ç»“æ„åŒ–æ˜¾ç¤º
        html = renderDefaultStructure(data);
      }

      return html;
    }

    function renderDefectAnalysis(data) {
      let html = '';
      if (data.å‘ç°çš„é—®é¢˜) {
        html += `<div class="result-section">
          <h4 class="section-title">ğŸ” å‘ç°çš„é—®é¢˜</h4>
          <div class="section-content">${formatText(data.å‘ç°çš„é—®é¢˜)}</div>
        </div>`;
      }
      if (data.æ”¹è¿›å»ºè®®) {
        html += `<div class="result-section">
          <h4 class="section-title">ğŸ’¡ æ”¹è¿›å»ºè®®</h4>
          <div class="section-content">${formatText(data.æ”¹è¿›å»ºè®®)}</div>
        </div>`;
      }
      return html || renderDefaultStructure(data);
    }

    function renderConsistencyAnalysis(data) {
      let html = '';
      if (data.ä¸€è‡´æ€§æ£€æŸ¥) {
        html += `<div class="result-section">
          <h4 class="section-title">ğŸ§  ä¸€è‡´æ€§æ£€æŸ¥ç»“æœ</h4>
          <div class="section-content">${formatText(data.ä¸€è‡´æ€§æ£€æŸ¥)}</div>
        </div>`;
      }
      if (data.æ½œåœ¨å†²çª) {
        html += `<div class="result-section">
          <h4 class="section-title">âš ï¸ æ½œåœ¨å†²çª</h4>
          <div class="section-content warning">${formatText(data.æ½œåœ¨å†²çª)}</div>
        </div>`;
      }
      return html || renderDefaultStructure(data);
    }

    function renderTechnicalSuggestions(data) {
      let html = '';
      if (data.æ¨èæ–¹æ¡ˆ) {
        html += `<div class="result-section">
          <h4 class="section-title">ğŸ’¡ æ¨èæŠ€æœ¯æ–¹æ¡ˆ</h4>
          <div class="section-content">${formatText(data.æ¨èæ–¹æ¡ˆ)}</div>
        </div>`;
      }
      if (data.ä¼˜åŠ¿) {
        html += `<div class="result-section">
          <h4 class="section-title">âœ… æ–¹æ¡ˆä¼˜åŠ¿</h4>
          <div class="section-content success">${formatText(data.ä¼˜åŠ¿)}</div>
        </div>`;
      }
      return html || renderDefaultStructure(data);
    }

    function renderRiskAssessment(data) {
      let html = '';
      if (data.é£é™©ç­‰çº§) {
        const riskLevel = data.é£é™©ç­‰çº§.toLowerCase();
        const riskClass = riskLevel.includes('é«˜') ? 'warning' : riskLevel.includes('ä¸­') ? 'highlight' : 'success';
        html += `<div class="result-section">
          <h4 class="section-title">âš ï¸ é£é™©ç­‰çº§</h4>
          <div class="section-content ${riskClass}">${data.é£é™©ç­‰çº§}</div>
        </div>`;
      }
      if (data.é£é™©æè¿°) {
        html += `<div class="result-section">
          <h4 class="section-title">ğŸ“ é£é™©æè¿°</h4>
          <div class="section-content">${formatText(data.é£é™©æè¿°)}</div>
        </div>`;
      }
      if (data.ç¼“è§£æªæ–½) {
        html += `<div class="result-section">
          <h4 class="section-title">ğŸ›¡ï¸ ç¼“è§£æªæ–½</h4>
          <div class="section-content">${formatText(data.ç¼“è§£æªæ–½)}</div>
        </div>`;
      }
      return html || renderDefaultStructure(data);
    }

    function renderDefaultStructure(data) {
      let html = '';
      for (const [label, content] of Object.entries(data)) {
        html += `<div class="analysis-item">
          <div class="analysis-label">${label}:</div>
          <div class="analysis-text">${formatText(content)}</div>
        </div>`;
      }
      return html;
    }

    function formatText(text) {
      if (typeof text !== 'string') return JSON.stringify(text, null, 2);

      // å¤„ç†ç¼–å·åˆ—è¡¨æ ¼å¼ï¼ˆå¦‚ï¼š1. å†…å®¹\n2. å†…å®¹ï¼‰
      const lines = text.split('\n');
      const formattedLines = lines.map(line => {
        // æ£€æŸ¥æ˜¯å¦æ˜¯ç¼–å·é¡¹ç›®ï¼ˆä»¥æ•°å­—+ç‚¹+ç©ºæ ¼å¼€å¤´ï¼‰
        if (/^\d+\.\s/.test(line)) {
          return `<div class="analysis-item">${line}</div>`;
        }
        // æ£€æŸ¥æ˜¯å¦æ˜¯æ— ç¼–å·çš„æ®µè½
        else if (line.trim()) {
          return `<p>${line.trim()}</p>`;
        }
        return '';
      }).filter(line => line);

      return formattedLines.join('');
    }

    console.log('Initialization complete');
    } // å…³é—­initializeAppå‡½æ•°
  </script>
</body>
</html>

